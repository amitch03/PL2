//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.2 Mini.g 2014-11-13 16:55:50

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


   /* package declaration here */


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.2")]
[System.CLSCompliant(false)]
public partial class MiniLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int AND=4;
	public const int ARGS=5;
	public const int ASSIGN=6;
	public const int BLOCK=7;
	public const int BOOL=8;
	public const int COMMA=9;
	public const int COMMENT=10;
	public const int DECL=11;
	public const int DECLLIST=12;
	public const int DECLS=13;
	public const int DELETE=14;
	public const int DIVIDE=15;
	public const int DOT=16;
	public const int ELSE=17;
	public const int ENDL=18;
	public const int EQ=19;
	public const int FALSE=20;
	public const int FUN=21;
	public const int FUNCS=22;
	public const int GE=23;
	public const int GT=24;
	public const int ID=25;
	public const int IF=26;
	public const int INT=27;
	public const int INTEGER=28;
	public const int INVOKE=29;
	public const int LBRACE=30;
	public const int LE=31;
	public const int LPAREN=32;
	public const int LT=33;
	public const int MINUS=34;
	public const int NE=35;
	public const int NEG=36;
	public const int NEW=37;
	public const int NOT=38;
	public const int NULL=39;
	public const int OR=40;
	public const int PARAMS=41;
	public const int PLUS=42;
	public const int PRINT=43;
	public const int PROGRAM=44;
	public const int RBRACE=45;
	public const int READ=46;
	public const int RETTYPE=47;
	public const int RETURN=48;
	public const int RPAREN=49;
	public const int SEMI=50;
	public const int STMTS=51;
	public const int STRUCT=52;
	public const int TIMES=53;
	public const int TRUE=54;
	public const int TYPE=55;
	public const int TYPES=56;
	public const int VOID=57;
	public const int WHILE=58;
	public const int WS=59;

	// delegates
	// delegators

	public MiniLexer()
	{
		OnCreated();
	}

	public MiniLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public MiniLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "Mini.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_BOOL();
	partial void LeaveRule_BOOL();

	// $ANTLR start "BOOL"
	[GrammarRule("BOOL")]
	private void mBOOL()
	{
		EnterRule_BOOL();
		EnterRule("BOOL", 1);
		TraceIn("BOOL", 1);
		try
		{
			int _type = BOOL;
			int _channel = DefaultTokenChannel;
			// Mini.g:6:6: ( 'bool' )
			DebugEnterAlt(1);
			// Mini.g:6:8: 'bool'
			{
			DebugLocation(6, 8);
			Match("bool"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BOOL", 1);
			LeaveRule("BOOL", 1);
			LeaveRule_BOOL();
		}
	}
	// $ANTLR end "BOOL"

	partial void EnterRule_DELETE();
	partial void LeaveRule_DELETE();

	// $ANTLR start "DELETE"
	[GrammarRule("DELETE")]
	private void mDELETE()
	{
		EnterRule_DELETE();
		EnterRule("DELETE", 2);
		TraceIn("DELETE", 2);
		try
		{
			int _type = DELETE;
			int _channel = DefaultTokenChannel;
			// Mini.g:7:8: ( 'delete' )
			DebugEnterAlt(1);
			// Mini.g:7:10: 'delete'
			{
			DebugLocation(7, 10);
			Match("delete"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DELETE", 2);
			LeaveRule("DELETE", 2);
			LeaveRule_DELETE();
		}
	}
	// $ANTLR end "DELETE"

	partial void EnterRule_ELSE();
	partial void LeaveRule_ELSE();

	// $ANTLR start "ELSE"
	[GrammarRule("ELSE")]
	private void mELSE()
	{
		EnterRule_ELSE();
		EnterRule("ELSE", 3);
		TraceIn("ELSE", 3);
		try
		{
			int _type = ELSE;
			int _channel = DefaultTokenChannel;
			// Mini.g:8:6: ( 'else' )
			DebugEnterAlt(1);
			// Mini.g:8:8: 'else'
			{
			DebugLocation(8, 8);
			Match("else"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ELSE", 3);
			LeaveRule("ELSE", 3);
			LeaveRule_ELSE();
		}
	}
	// $ANTLR end "ELSE"

	partial void EnterRule_ENDL();
	partial void LeaveRule_ENDL();

	// $ANTLR start "ENDL"
	[GrammarRule("ENDL")]
	private void mENDL()
	{
		EnterRule_ENDL();
		EnterRule("ENDL", 4);
		TraceIn("ENDL", 4);
		try
		{
			int _type = ENDL;
			int _channel = DefaultTokenChannel;
			// Mini.g:9:6: ( 'endl' )
			DebugEnterAlt(1);
			// Mini.g:9:8: 'endl'
			{
			DebugLocation(9, 8);
			Match("endl"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ENDL", 4);
			LeaveRule("ENDL", 4);
			LeaveRule_ENDL();
		}
	}
	// $ANTLR end "ENDL"

	partial void EnterRule_FALSE();
	partial void LeaveRule_FALSE();

	// $ANTLR start "FALSE"
	[GrammarRule("FALSE")]
	private void mFALSE()
	{
		EnterRule_FALSE();
		EnterRule("FALSE", 5);
		TraceIn("FALSE", 5);
		try
		{
			int _type = FALSE;
			int _channel = DefaultTokenChannel;
			// Mini.g:10:7: ( 'false' )
			DebugEnterAlt(1);
			// Mini.g:10:9: 'false'
			{
			DebugLocation(10, 9);
			Match("false"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("FALSE", 5);
			LeaveRule("FALSE", 5);
			LeaveRule_FALSE();
		}
	}
	// $ANTLR end "FALSE"

	partial void EnterRule_FUN();
	partial void LeaveRule_FUN();

	// $ANTLR start "FUN"
	[GrammarRule("FUN")]
	private void mFUN()
	{
		EnterRule_FUN();
		EnterRule("FUN", 6);
		TraceIn("FUN", 6);
		try
		{
			int _type = FUN;
			int _channel = DefaultTokenChannel;
			// Mini.g:11:5: ( 'fun' )
			DebugEnterAlt(1);
			// Mini.g:11:7: 'fun'
			{
			DebugLocation(11, 7);
			Match("fun"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("FUN", 6);
			LeaveRule("FUN", 6);
			LeaveRule_FUN();
		}
	}
	// $ANTLR end "FUN"

	partial void EnterRule_IF();
	partial void LeaveRule_IF();

	// $ANTLR start "IF"
	[GrammarRule("IF")]
	private void mIF()
	{
		EnterRule_IF();
		EnterRule("IF", 7);
		TraceIn("IF", 7);
		try
		{
			int _type = IF;
			int _channel = DefaultTokenChannel;
			// Mini.g:12:4: ( 'if' )
			DebugEnterAlt(1);
			// Mini.g:12:6: 'if'
			{
			DebugLocation(12, 6);
			Match("if"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("IF", 7);
			LeaveRule("IF", 7);
			LeaveRule_IF();
		}
	}
	// $ANTLR end "IF"

	partial void EnterRule_INT();
	partial void LeaveRule_INT();

	// $ANTLR start "INT"
	[GrammarRule("INT")]
	private void mINT()
	{
		EnterRule_INT();
		EnterRule("INT", 8);
		TraceIn("INT", 8);
		try
		{
			int _type = INT;
			int _channel = DefaultTokenChannel;
			// Mini.g:13:5: ( 'int' )
			DebugEnterAlt(1);
			// Mini.g:13:7: 'int'
			{
			DebugLocation(13, 7);
			Match("int"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("INT", 8);
			LeaveRule("INT", 8);
			LeaveRule_INT();
		}
	}
	// $ANTLR end "INT"

	partial void EnterRule_NEW();
	partial void LeaveRule_NEW();

	// $ANTLR start "NEW"
	[GrammarRule("NEW")]
	private void mNEW()
	{
		EnterRule_NEW();
		EnterRule("NEW", 9);
		TraceIn("NEW", 9);
		try
		{
			int _type = NEW;
			int _channel = DefaultTokenChannel;
			// Mini.g:14:5: ( 'new' )
			DebugEnterAlt(1);
			// Mini.g:14:7: 'new'
			{
			DebugLocation(14, 7);
			Match("new"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NEW", 9);
			LeaveRule("NEW", 9);
			LeaveRule_NEW();
		}
	}
	// $ANTLR end "NEW"

	partial void EnterRule_NULL();
	partial void LeaveRule_NULL();

	// $ANTLR start "NULL"
	[GrammarRule("NULL")]
	private void mNULL()
	{
		EnterRule_NULL();
		EnterRule("NULL", 10);
		TraceIn("NULL", 10);
		try
		{
			int _type = NULL;
			int _channel = DefaultTokenChannel;
			// Mini.g:15:6: ( 'null' )
			DebugEnterAlt(1);
			// Mini.g:15:8: 'null'
			{
			DebugLocation(15, 8);
			Match("null"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NULL", 10);
			LeaveRule("NULL", 10);
			LeaveRule_NULL();
		}
	}
	// $ANTLR end "NULL"

	partial void EnterRule_PRINT();
	partial void LeaveRule_PRINT();

	// $ANTLR start "PRINT"
	[GrammarRule("PRINT")]
	private void mPRINT()
	{
		EnterRule_PRINT();
		EnterRule("PRINT", 11);
		TraceIn("PRINT", 11);
		try
		{
			int _type = PRINT;
			int _channel = DefaultTokenChannel;
			// Mini.g:16:7: ( 'print' )
			DebugEnterAlt(1);
			// Mini.g:16:9: 'print'
			{
			DebugLocation(16, 9);
			Match("print"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PRINT", 11);
			LeaveRule("PRINT", 11);
			LeaveRule_PRINT();
		}
	}
	// $ANTLR end "PRINT"

	partial void EnterRule_READ();
	partial void LeaveRule_READ();

	// $ANTLR start "READ"
	[GrammarRule("READ")]
	private void mREAD()
	{
		EnterRule_READ();
		EnterRule("READ", 12);
		TraceIn("READ", 12);
		try
		{
			int _type = READ;
			int _channel = DefaultTokenChannel;
			// Mini.g:17:6: ( 'read' )
			DebugEnterAlt(1);
			// Mini.g:17:8: 'read'
			{
			DebugLocation(17, 8);
			Match("read"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("READ", 12);
			LeaveRule("READ", 12);
			LeaveRule_READ();
		}
	}
	// $ANTLR end "READ"

	partial void EnterRule_RETURN();
	partial void LeaveRule_RETURN();

	// $ANTLR start "RETURN"
	[GrammarRule("RETURN")]
	private void mRETURN()
	{
		EnterRule_RETURN();
		EnterRule("RETURN", 13);
		TraceIn("RETURN", 13);
		try
		{
			int _type = RETURN;
			int _channel = DefaultTokenChannel;
			// Mini.g:18:8: ( 'return' )
			DebugEnterAlt(1);
			// Mini.g:18:10: 'return'
			{
			DebugLocation(18, 10);
			Match("return"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RETURN", 13);
			LeaveRule("RETURN", 13);
			LeaveRule_RETURN();
		}
	}
	// $ANTLR end "RETURN"

	partial void EnterRule_STRUCT();
	partial void LeaveRule_STRUCT();

	// $ANTLR start "STRUCT"
	[GrammarRule("STRUCT")]
	private void mSTRUCT()
	{
		EnterRule_STRUCT();
		EnterRule("STRUCT", 14);
		TraceIn("STRUCT", 14);
		try
		{
			int _type = STRUCT;
			int _channel = DefaultTokenChannel;
			// Mini.g:19:8: ( 'struct' )
			DebugEnterAlt(1);
			// Mini.g:19:10: 'struct'
			{
			DebugLocation(19, 10);
			Match("struct"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("STRUCT", 14);
			LeaveRule("STRUCT", 14);
			LeaveRule_STRUCT();
		}
	}
	// $ANTLR end "STRUCT"

	partial void EnterRule_TRUE();
	partial void LeaveRule_TRUE();

	// $ANTLR start "TRUE"
	[GrammarRule("TRUE")]
	private void mTRUE()
	{
		EnterRule_TRUE();
		EnterRule("TRUE", 15);
		TraceIn("TRUE", 15);
		try
		{
			int _type = TRUE;
			int _channel = DefaultTokenChannel;
			// Mini.g:20:6: ( 'true' )
			DebugEnterAlt(1);
			// Mini.g:20:8: 'true'
			{
			DebugLocation(20, 8);
			Match("true"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("TRUE", 15);
			LeaveRule("TRUE", 15);
			LeaveRule_TRUE();
		}
	}
	// $ANTLR end "TRUE"

	partial void EnterRule_VOID();
	partial void LeaveRule_VOID();

	// $ANTLR start "VOID"
	[GrammarRule("VOID")]
	private void mVOID()
	{
		EnterRule_VOID();
		EnterRule("VOID", 16);
		TraceIn("VOID", 16);
		try
		{
			int _type = VOID;
			int _channel = DefaultTokenChannel;
			// Mini.g:21:6: ( 'void' )
			DebugEnterAlt(1);
			// Mini.g:21:8: 'void'
			{
			DebugLocation(21, 8);
			Match("void"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("VOID", 16);
			LeaveRule("VOID", 16);
			LeaveRule_VOID();
		}
	}
	// $ANTLR end "VOID"

	partial void EnterRule_WHILE();
	partial void LeaveRule_WHILE();

	// $ANTLR start "WHILE"
	[GrammarRule("WHILE")]
	private void mWHILE()
	{
		EnterRule_WHILE();
		EnterRule("WHILE", 17);
		TraceIn("WHILE", 17);
		try
		{
			int _type = WHILE;
			int _channel = DefaultTokenChannel;
			// Mini.g:22:7: ( 'while' )
			DebugEnterAlt(1);
			// Mini.g:22:9: 'while'
			{
			DebugLocation(22, 9);
			Match("while"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WHILE", 17);
			LeaveRule("WHILE", 17);
			LeaveRule_WHILE();
		}
	}
	// $ANTLR end "WHILE"

	partial void EnterRule_LBRACE();
	partial void LeaveRule_LBRACE();

	// $ANTLR start "LBRACE"
	[GrammarRule("LBRACE")]
	private void mLBRACE()
	{
		EnterRule_LBRACE();
		EnterRule("LBRACE", 18);
		TraceIn("LBRACE", 18);
		try
		{
			int _type = LBRACE;
			int _channel = DefaultTokenChannel;
			// Mini.g:94:10: ( '{' )
			DebugEnterAlt(1);
			// Mini.g:94:13: '{'
			{
			DebugLocation(94, 13);
			Match('{'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LBRACE", 18);
			LeaveRule("LBRACE", 18);
			LeaveRule_LBRACE();
		}
	}
	// $ANTLR end "LBRACE"

	partial void EnterRule_RBRACE();
	partial void LeaveRule_RBRACE();

	// $ANTLR start "RBRACE"
	[GrammarRule("RBRACE")]
	private void mRBRACE()
	{
		EnterRule_RBRACE();
		EnterRule("RBRACE", 19);
		TraceIn("RBRACE", 19);
		try
		{
			int _type = RBRACE;
			int _channel = DefaultTokenChannel;
			// Mini.g:95:10: ( '}' )
			DebugEnterAlt(1);
			// Mini.g:95:13: '}'
			{
			DebugLocation(95, 13);
			Match('}'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RBRACE", 19);
			LeaveRule("RBRACE", 19);
			LeaveRule_RBRACE();
		}
	}
	// $ANTLR end "RBRACE"

	partial void EnterRule_SEMI();
	partial void LeaveRule_SEMI();

	// $ANTLR start "SEMI"
	[GrammarRule("SEMI")]
	private void mSEMI()
	{
		EnterRule_SEMI();
		EnterRule("SEMI", 20);
		TraceIn("SEMI", 20);
		try
		{
			int _type = SEMI;
			int _channel = DefaultTokenChannel;
			// Mini.g:96:10: ( ';' )
			DebugEnterAlt(1);
			// Mini.g:96:13: ';'
			{
			DebugLocation(96, 13);
			Match(';'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SEMI", 20);
			LeaveRule("SEMI", 20);
			LeaveRule_SEMI();
		}
	}
	// $ANTLR end "SEMI"

	partial void EnterRule_COMMA();
	partial void LeaveRule_COMMA();

	// $ANTLR start "COMMA"
	[GrammarRule("COMMA")]
	private void mCOMMA()
	{
		EnterRule_COMMA();
		EnterRule("COMMA", 21);
		TraceIn("COMMA", 21);
		try
		{
			int _type = COMMA;
			int _channel = DefaultTokenChannel;
			// Mini.g:97:10: ( ',' )
			DebugEnterAlt(1);
			// Mini.g:97:13: ','
			{
			DebugLocation(97, 13);
			Match(','); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("COMMA", 21);
			LeaveRule("COMMA", 21);
			LeaveRule_COMMA();
		}
	}
	// $ANTLR end "COMMA"

	partial void EnterRule_LPAREN();
	partial void LeaveRule_LPAREN();

	// $ANTLR start "LPAREN"
	[GrammarRule("LPAREN")]
	private void mLPAREN()
	{
		EnterRule_LPAREN();
		EnterRule("LPAREN", 22);
		TraceIn("LPAREN", 22);
		try
		{
			int _type = LPAREN;
			int _channel = DefaultTokenChannel;
			// Mini.g:98:10: ( '(' )
			DebugEnterAlt(1);
			// Mini.g:98:13: '('
			{
			DebugLocation(98, 13);
			Match('('); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LPAREN", 22);
			LeaveRule("LPAREN", 22);
			LeaveRule_LPAREN();
		}
	}
	// $ANTLR end "LPAREN"

	partial void EnterRule_RPAREN();
	partial void LeaveRule_RPAREN();

	// $ANTLR start "RPAREN"
	[GrammarRule("RPAREN")]
	private void mRPAREN()
	{
		EnterRule_RPAREN();
		EnterRule("RPAREN", 23);
		TraceIn("RPAREN", 23);
		try
		{
			int _type = RPAREN;
			int _channel = DefaultTokenChannel;
			// Mini.g:99:10: ( ')' )
			DebugEnterAlt(1);
			// Mini.g:99:13: ')'
			{
			DebugLocation(99, 13);
			Match(')'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RPAREN", 23);
			LeaveRule("RPAREN", 23);
			LeaveRule_RPAREN();
		}
	}
	// $ANTLR end "RPAREN"

	partial void EnterRule_ASSIGN();
	partial void LeaveRule_ASSIGN();

	// $ANTLR start "ASSIGN"
	[GrammarRule("ASSIGN")]
	private void mASSIGN()
	{
		EnterRule_ASSIGN();
		EnterRule("ASSIGN", 24);
		TraceIn("ASSIGN", 24);
		try
		{
			int _type = ASSIGN;
			int _channel = DefaultTokenChannel;
			// Mini.g:100:10: ( '=' )
			DebugEnterAlt(1);
			// Mini.g:100:13: '='
			{
			DebugLocation(100, 13);
			Match('='); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ASSIGN", 24);
			LeaveRule("ASSIGN", 24);
			LeaveRule_ASSIGN();
		}
	}
	// $ANTLR end "ASSIGN"

	partial void EnterRule_DOT();
	partial void LeaveRule_DOT();

	// $ANTLR start "DOT"
	[GrammarRule("DOT")]
	private void mDOT()
	{
		EnterRule_DOT();
		EnterRule("DOT", 25);
		TraceIn("DOT", 25);
		try
		{
			int _type = DOT;
			int _channel = DefaultTokenChannel;
			// Mini.g:101:10: ( '.' )
			DebugEnterAlt(1);
			// Mini.g:101:13: '.'
			{
			DebugLocation(101, 13);
			Match('.'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DOT", 25);
			LeaveRule("DOT", 25);
			LeaveRule_DOT();
		}
	}
	// $ANTLR end "DOT"

	partial void EnterRule_AND();
	partial void LeaveRule_AND();

	// $ANTLR start "AND"
	[GrammarRule("AND")]
	private void mAND()
	{
		EnterRule_AND();
		EnterRule("AND", 26);
		TraceIn("AND", 26);
		try
		{
			int _type = AND;
			int _channel = DefaultTokenChannel;
			// Mini.g:102:10: ( '&&' )
			DebugEnterAlt(1);
			// Mini.g:102:13: '&&'
			{
			DebugLocation(102, 13);
			Match("&&"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("AND", 26);
			LeaveRule("AND", 26);
			LeaveRule_AND();
		}
	}
	// $ANTLR end "AND"

	partial void EnterRule_OR();
	partial void LeaveRule_OR();

	// $ANTLR start "OR"
	[GrammarRule("OR")]
	private void mOR()
	{
		EnterRule_OR();
		EnterRule("OR", 27);
		TraceIn("OR", 27);
		try
		{
			int _type = OR;
			int _channel = DefaultTokenChannel;
			// Mini.g:103:10: ( '||' )
			DebugEnterAlt(1);
			// Mini.g:103:13: '||'
			{
			DebugLocation(103, 13);
			Match("||"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OR", 27);
			LeaveRule("OR", 27);
			LeaveRule_OR();
		}
	}
	// $ANTLR end "OR"

	partial void EnterRule_EQ();
	partial void LeaveRule_EQ();

	// $ANTLR start "EQ"
	[GrammarRule("EQ")]
	private void mEQ()
	{
		EnterRule_EQ();
		EnterRule("EQ", 28);
		TraceIn("EQ", 28);
		try
		{
			int _type = EQ;
			int _channel = DefaultTokenChannel;
			// Mini.g:104:10: ( '==' )
			DebugEnterAlt(1);
			// Mini.g:104:13: '=='
			{
			DebugLocation(104, 13);
			Match("=="); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("EQ", 28);
			LeaveRule("EQ", 28);
			LeaveRule_EQ();
		}
	}
	// $ANTLR end "EQ"

	partial void EnterRule_LT();
	partial void LeaveRule_LT();

	// $ANTLR start "LT"
	[GrammarRule("LT")]
	private void mLT()
	{
		EnterRule_LT();
		EnterRule("LT", 29);
		TraceIn("LT", 29);
		try
		{
			int _type = LT;
			int _channel = DefaultTokenChannel;
			// Mini.g:105:10: ( '<' )
			DebugEnterAlt(1);
			// Mini.g:105:13: '<'
			{
			DebugLocation(105, 13);
			Match('<'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LT", 29);
			LeaveRule("LT", 29);
			LeaveRule_LT();
		}
	}
	// $ANTLR end "LT"

	partial void EnterRule_GT();
	partial void LeaveRule_GT();

	// $ANTLR start "GT"
	[GrammarRule("GT")]
	private void mGT()
	{
		EnterRule_GT();
		EnterRule("GT", 30);
		TraceIn("GT", 30);
		try
		{
			int _type = GT;
			int _channel = DefaultTokenChannel;
			// Mini.g:106:10: ( '>' )
			DebugEnterAlt(1);
			// Mini.g:106:13: '>'
			{
			DebugLocation(106, 13);
			Match('>'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("GT", 30);
			LeaveRule("GT", 30);
			LeaveRule_GT();
		}
	}
	// $ANTLR end "GT"

	partial void EnterRule_NE();
	partial void LeaveRule_NE();

	// $ANTLR start "NE"
	[GrammarRule("NE")]
	private void mNE()
	{
		EnterRule_NE();
		EnterRule("NE", 31);
		TraceIn("NE", 31);
		try
		{
			int _type = NE;
			int _channel = DefaultTokenChannel;
			// Mini.g:107:10: ( '!=' )
			DebugEnterAlt(1);
			// Mini.g:107:13: '!='
			{
			DebugLocation(107, 13);
			Match("!="); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NE", 31);
			LeaveRule("NE", 31);
			LeaveRule_NE();
		}
	}
	// $ANTLR end "NE"

	partial void EnterRule_LE();
	partial void LeaveRule_LE();

	// $ANTLR start "LE"
	[GrammarRule("LE")]
	private void mLE()
	{
		EnterRule_LE();
		EnterRule("LE", 32);
		TraceIn("LE", 32);
		try
		{
			int _type = LE;
			int _channel = DefaultTokenChannel;
			// Mini.g:108:10: ( '<=' )
			DebugEnterAlt(1);
			// Mini.g:108:13: '<='
			{
			DebugLocation(108, 13);
			Match("<="); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LE", 32);
			LeaveRule("LE", 32);
			LeaveRule_LE();
		}
	}
	// $ANTLR end "LE"

	partial void EnterRule_GE();
	partial void LeaveRule_GE();

	// $ANTLR start "GE"
	[GrammarRule("GE")]
	private void mGE()
	{
		EnterRule_GE();
		EnterRule("GE", 33);
		TraceIn("GE", 33);
		try
		{
			int _type = GE;
			int _channel = DefaultTokenChannel;
			// Mini.g:109:10: ( '>=' )
			DebugEnterAlt(1);
			// Mini.g:109:13: '>='
			{
			DebugLocation(109, 13);
			Match(">="); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("GE", 33);
			LeaveRule("GE", 33);
			LeaveRule_GE();
		}
	}
	// $ANTLR end "GE"

	partial void EnterRule_PLUS();
	partial void LeaveRule_PLUS();

	// $ANTLR start "PLUS"
	[GrammarRule("PLUS")]
	private void mPLUS()
	{
		EnterRule_PLUS();
		EnterRule("PLUS", 34);
		TraceIn("PLUS", 34);
		try
		{
			int _type = PLUS;
			int _channel = DefaultTokenChannel;
			// Mini.g:110:10: ( '+' )
			DebugEnterAlt(1);
			// Mini.g:110:13: '+'
			{
			DebugLocation(110, 13);
			Match('+'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PLUS", 34);
			LeaveRule("PLUS", 34);
			LeaveRule_PLUS();
		}
	}
	// $ANTLR end "PLUS"

	partial void EnterRule_MINUS();
	partial void LeaveRule_MINUS();

	// $ANTLR start "MINUS"
	[GrammarRule("MINUS")]
	private void mMINUS()
	{
		EnterRule_MINUS();
		EnterRule("MINUS", 35);
		TraceIn("MINUS", 35);
		try
		{
			int _type = MINUS;
			int _channel = DefaultTokenChannel;
			// Mini.g:111:10: ( '-' )
			DebugEnterAlt(1);
			// Mini.g:111:13: '-'
			{
			DebugLocation(111, 13);
			Match('-'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("MINUS", 35);
			LeaveRule("MINUS", 35);
			LeaveRule_MINUS();
		}
	}
	// $ANTLR end "MINUS"

	partial void EnterRule_TIMES();
	partial void LeaveRule_TIMES();

	// $ANTLR start "TIMES"
	[GrammarRule("TIMES")]
	private void mTIMES()
	{
		EnterRule_TIMES();
		EnterRule("TIMES", 36);
		TraceIn("TIMES", 36);
		try
		{
			int _type = TIMES;
			int _channel = DefaultTokenChannel;
			// Mini.g:112:10: ( '*' )
			DebugEnterAlt(1);
			// Mini.g:112:13: '*'
			{
			DebugLocation(112, 13);
			Match('*'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("TIMES", 36);
			LeaveRule("TIMES", 36);
			LeaveRule_TIMES();
		}
	}
	// $ANTLR end "TIMES"

	partial void EnterRule_DIVIDE();
	partial void LeaveRule_DIVIDE();

	// $ANTLR start "DIVIDE"
	[GrammarRule("DIVIDE")]
	private void mDIVIDE()
	{
		EnterRule_DIVIDE();
		EnterRule("DIVIDE", 37);
		TraceIn("DIVIDE", 37);
		try
		{
			int _type = DIVIDE;
			int _channel = DefaultTokenChannel;
			// Mini.g:113:10: ( '/' )
			DebugEnterAlt(1);
			// Mini.g:113:13: '/'
			{
			DebugLocation(113, 13);
			Match('/'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DIVIDE", 37);
			LeaveRule("DIVIDE", 37);
			LeaveRule_DIVIDE();
		}
	}
	// $ANTLR end "DIVIDE"

	partial void EnterRule_NOT();
	partial void LeaveRule_NOT();

	// $ANTLR start "NOT"
	[GrammarRule("NOT")]
	private void mNOT()
	{
		EnterRule_NOT();
		EnterRule("NOT", 38);
		TraceIn("NOT", 38);
		try
		{
			int _type = NOT;
			int _channel = DefaultTokenChannel;
			// Mini.g:114:10: ( '!' )
			DebugEnterAlt(1);
			// Mini.g:114:13: '!'
			{
			DebugLocation(114, 13);
			Match('!'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NOT", 38);
			LeaveRule("NOT", 38);
			LeaveRule_NOT();
		}
	}
	// $ANTLR end "NOT"

	partial void EnterRule_ID();
	partial void LeaveRule_ID();

	// $ANTLR start "ID"
	[GrammarRule("ID")]
	private void mID()
	{
		EnterRule_ID();
		EnterRule("ID", 39);
		TraceIn("ID", 39);
		try
		{
			int _type = ID;
			int _channel = DefaultTokenChannel;
			// Mini.g:116:10: ( ( 'a' .. 'z' | 'A' .. 'Z' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' )* )
			DebugEnterAlt(1);
			// Mini.g:116:13: ( 'a' .. 'z' | 'A' .. 'Z' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' )*
			{
			DebugLocation(116, 13);
			if ((input.LA(1)>='A' && input.LA(1)<='Z')||(input.LA(1)>='a' && input.LA(1)<='z'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(116, 34);
			// Mini.g:116:34: ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if (((LA1_1>='0' && LA1_1<='9')||(LA1_1>='A' && LA1_1<='Z')||(LA1_1>='a' && LA1_1<='z')))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// Mini.g:
					{
					DebugLocation(116, 34);
					input.Consume();


					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ID", 39);
			LeaveRule("ID", 39);
			LeaveRule_ID();
		}
	}
	// $ANTLR end "ID"

	partial void EnterRule_INTEGER();
	partial void LeaveRule_INTEGER();

	// $ANTLR start "INTEGER"
	[GrammarRule("INTEGER")]
	private void mINTEGER()
	{
		EnterRule_INTEGER();
		EnterRule("INTEGER", 40);
		TraceIn("INTEGER", 40);
		try
		{
			int _type = INTEGER;
			int _channel = DefaultTokenChannel;
			// Mini.g:118:10: ( '0' | ( '1' .. '9' ) ( '0' .. '9' )* )
			int alt3=2;
			try { DebugEnterDecision(3, false);
			int LA3_1 = input.LA(1);

			if ((LA3_1=='0'))
			{
				alt3 = 1;
			}
			else if (((LA3_1>='1' && LA3_1<='9')))
			{
				alt3 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 3, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// Mini.g:118:13: '0'
				{
				DebugLocation(118, 13);
				Match('0'); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Mini.g:118:19: ( '1' .. '9' ) ( '0' .. '9' )*
				{
				DebugLocation(118, 19);
				input.Consume();

				DebugLocation(118, 30);
				// Mini.g:118:30: ( '0' .. '9' )*
				try { DebugEnterSubRule(2);
				while (true)
				{
					int alt2=2;
					try { DebugEnterDecision(2, false);
					int LA2_1 = input.LA(1);

					if (((LA2_1>='0' && LA2_1<='9')))
					{
						alt2 = 1;
					}


					} finally { DebugExitDecision(2); }
					switch ( alt2 )
					{
					case 1:
						DebugEnterAlt(1);
						// Mini.g:
						{
						DebugLocation(118, 30);
						input.Consume();


						}
						break;

					default:
						goto loop2;
					}
				}

				loop2:
					;

				} finally { DebugExitSubRule(2); }


				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("INTEGER", 40);
			LeaveRule("INTEGER", 40);
			LeaveRule_INTEGER();
		}
	}
	// $ANTLR end "INTEGER"

	partial void EnterRule_WS();
	partial void LeaveRule_WS();

	// $ANTLR start "WS"
	[GrammarRule("WS")]
	private void mWS()
	{
		EnterRule_WS();
		EnterRule("WS", 41);
		TraceIn("WS", 41);
		try
		{
			int _type = WS;
			int _channel = DefaultTokenChannel;
			// Mini.g:120:10: ( ( ' ' | '\\t' | '\\f' | '\\r' | '\\n' )+ )
			DebugEnterAlt(1);
			// Mini.g:120:13: ( ' ' | '\\t' | '\\f' | '\\r' | '\\n' )+
			{
			DebugLocation(120, 13);
			// Mini.g:120:13: ( ' ' | '\\t' | '\\f' | '\\r' | '\\n' )+
			int cnt4=0;
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if (((LA4_1>='\t' && LA4_1<='\n')||(LA4_1>='\f' && LA4_1<='\r')||LA4_1==' '))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch (alt4)
				{
				case 1:
					DebugEnterAlt(1);
					// Mini.g:
					{
					DebugLocation(120, 13);
					input.Consume();


					}
					break;

				default:
					if (cnt4 >= 1)
						goto loop4;

					EarlyExitException eee4 = new EarlyExitException( 4, input );
					DebugRecognitionException(eee4);
					throw eee4;
				}
				cnt4++;
			}
			loop4:
				;

			} finally { DebugExitSubRule(4); }

			DebugLocation(126, 13);
			 Compiler.Lexer.Skip(); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WS", 41);
			LeaveRule("WS", 41);
			LeaveRule_WS();
		}
	}
	// $ANTLR end "WS"

	partial void EnterRule_COMMENT();
	partial void LeaveRule_COMMENT();

	// $ANTLR start "COMMENT"
	[GrammarRule("COMMENT")]
	private void mCOMMENT()
	{
		EnterRule_COMMENT();
		EnterRule("COMMENT", 42);
		TraceIn("COMMENT", 42);
		try
		{
			int _type = COMMENT;
			int _channel = DefaultTokenChannel;
			// Mini.g:129:10: ( '#' (~ '\\n' )* '\\n' )
			DebugEnterAlt(1);
			// Mini.g:129:13: '#' (~ '\\n' )* '\\n'
			{
			DebugLocation(129, 13);
			Match('#'); 
			DebugLocation(129, 17);
			// Mini.g:129:17: (~ '\\n' )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_1 = input.LA(1);

				if (((LA5_1>='\u0000' && LA5_1<='\t')||(LA5_1>='\u000B' && LA5_1<='\uFFFF')))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// Mini.g:
					{
					DebugLocation(129, 17);
					input.Consume();


					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }

			DebugLocation(129, 26);
			Match('\n'); 
			DebugLocation(130, 13);
			 Compiler.Lexer.Skip(); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("COMMENT", 42);
			LeaveRule("COMMENT", 42);
			LeaveRule_COMMENT();
		}
	}
	// $ANTLR end "COMMENT"

	public override void mTokens()
	{
		// Mini.g:1:8: ( BOOL | DELETE | ELSE | ENDL | FALSE | FUN | IF | INT | NEW | NULL | PRINT | READ | RETURN | STRUCT | TRUE | VOID | WHILE | LBRACE | RBRACE | SEMI | COMMA | LPAREN | RPAREN | ASSIGN | DOT | AND | OR | EQ | LT | GT | NE | LE | GE | PLUS | MINUS | TIMES | DIVIDE | NOT | ID | INTEGER | WS | COMMENT )
		int alt6=42;
		try { DebugEnterDecision(6, false);
		try
		{
			alt6 = dfa6.Predict(input);
		}
		catch (NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
			throw;
		}
		} finally { DebugExitDecision(6); }
		switch (alt6)
		{
		case 1:
			DebugEnterAlt(1);
			// Mini.g:1:10: BOOL
			{
			DebugLocation(1, 10);
			mBOOL(); 

			}
			break;
		case 2:
			DebugEnterAlt(2);
			// Mini.g:1:15: DELETE
			{
			DebugLocation(1, 15);
			mDELETE(); 

			}
			break;
		case 3:
			DebugEnterAlt(3);
			// Mini.g:1:22: ELSE
			{
			DebugLocation(1, 22);
			mELSE(); 

			}
			break;
		case 4:
			DebugEnterAlt(4);
			// Mini.g:1:27: ENDL
			{
			DebugLocation(1, 27);
			mENDL(); 

			}
			break;
		case 5:
			DebugEnterAlt(5);
			// Mini.g:1:32: FALSE
			{
			DebugLocation(1, 32);
			mFALSE(); 

			}
			break;
		case 6:
			DebugEnterAlt(6);
			// Mini.g:1:38: FUN
			{
			DebugLocation(1, 38);
			mFUN(); 

			}
			break;
		case 7:
			DebugEnterAlt(7);
			// Mini.g:1:42: IF
			{
			DebugLocation(1, 42);
			mIF(); 

			}
			break;
		case 8:
			DebugEnterAlt(8);
			// Mini.g:1:45: INT
			{
			DebugLocation(1, 45);
			mINT(); 

			}
			break;
		case 9:
			DebugEnterAlt(9);
			// Mini.g:1:49: NEW
			{
			DebugLocation(1, 49);
			mNEW(); 

			}
			break;
		case 10:
			DebugEnterAlt(10);
			// Mini.g:1:53: NULL
			{
			DebugLocation(1, 53);
			mNULL(); 

			}
			break;
		case 11:
			DebugEnterAlt(11);
			// Mini.g:1:58: PRINT
			{
			DebugLocation(1, 58);
			mPRINT(); 

			}
			break;
		case 12:
			DebugEnterAlt(12);
			// Mini.g:1:64: READ
			{
			DebugLocation(1, 64);
			mREAD(); 

			}
			break;
		case 13:
			DebugEnterAlt(13);
			// Mini.g:1:69: RETURN
			{
			DebugLocation(1, 69);
			mRETURN(); 

			}
			break;
		case 14:
			DebugEnterAlt(14);
			// Mini.g:1:76: STRUCT
			{
			DebugLocation(1, 76);
			mSTRUCT(); 

			}
			break;
		case 15:
			DebugEnterAlt(15);
			// Mini.g:1:83: TRUE
			{
			DebugLocation(1, 83);
			mTRUE(); 

			}
			break;
		case 16:
			DebugEnterAlt(16);
			// Mini.g:1:88: VOID
			{
			DebugLocation(1, 88);
			mVOID(); 

			}
			break;
		case 17:
			DebugEnterAlt(17);
			// Mini.g:1:93: WHILE
			{
			DebugLocation(1, 93);
			mWHILE(); 

			}
			break;
		case 18:
			DebugEnterAlt(18);
			// Mini.g:1:99: LBRACE
			{
			DebugLocation(1, 99);
			mLBRACE(); 

			}
			break;
		case 19:
			DebugEnterAlt(19);
			// Mini.g:1:106: RBRACE
			{
			DebugLocation(1, 106);
			mRBRACE(); 

			}
			break;
		case 20:
			DebugEnterAlt(20);
			// Mini.g:1:113: SEMI
			{
			DebugLocation(1, 113);
			mSEMI(); 

			}
			break;
		case 21:
			DebugEnterAlt(21);
			// Mini.g:1:118: COMMA
			{
			DebugLocation(1, 118);
			mCOMMA(); 

			}
			break;
		case 22:
			DebugEnterAlt(22);
			// Mini.g:1:124: LPAREN
			{
			DebugLocation(1, 124);
			mLPAREN(); 

			}
			break;
		case 23:
			DebugEnterAlt(23);
			// Mini.g:1:131: RPAREN
			{
			DebugLocation(1, 131);
			mRPAREN(); 

			}
			break;
		case 24:
			DebugEnterAlt(24);
			// Mini.g:1:138: ASSIGN
			{
			DebugLocation(1, 138);
			mASSIGN(); 

			}
			break;
		case 25:
			DebugEnterAlt(25);
			// Mini.g:1:145: DOT
			{
			DebugLocation(1, 145);
			mDOT(); 

			}
			break;
		case 26:
			DebugEnterAlt(26);
			// Mini.g:1:149: AND
			{
			DebugLocation(1, 149);
			mAND(); 

			}
			break;
		case 27:
			DebugEnterAlt(27);
			// Mini.g:1:153: OR
			{
			DebugLocation(1, 153);
			mOR(); 

			}
			break;
		case 28:
			DebugEnterAlt(28);
			// Mini.g:1:156: EQ
			{
			DebugLocation(1, 156);
			mEQ(); 

			}
			break;
		case 29:
			DebugEnterAlt(29);
			// Mini.g:1:159: LT
			{
			DebugLocation(1, 159);
			mLT(); 

			}
			break;
		case 30:
			DebugEnterAlt(30);
			// Mini.g:1:162: GT
			{
			DebugLocation(1, 162);
			mGT(); 

			}
			break;
		case 31:
			DebugEnterAlt(31);
			// Mini.g:1:165: NE
			{
			DebugLocation(1, 165);
			mNE(); 

			}
			break;
		case 32:
			DebugEnterAlt(32);
			// Mini.g:1:168: LE
			{
			DebugLocation(1, 168);
			mLE(); 

			}
			break;
		case 33:
			DebugEnterAlt(33);
			// Mini.g:1:171: GE
			{
			DebugLocation(1, 171);
			mGE(); 

			}
			break;
		case 34:
			DebugEnterAlt(34);
			// Mini.g:1:174: PLUS
			{
			DebugLocation(1, 174);
			mPLUS(); 

			}
			break;
		case 35:
			DebugEnterAlt(35);
			// Mini.g:1:179: MINUS
			{
			DebugLocation(1, 179);
			mMINUS(); 

			}
			break;
		case 36:
			DebugEnterAlt(36);
			// Mini.g:1:185: TIMES
			{
			DebugLocation(1, 185);
			mTIMES(); 

			}
			break;
		case 37:
			DebugEnterAlt(37);
			// Mini.g:1:191: DIVIDE
			{
			DebugLocation(1, 191);
			mDIVIDE(); 

			}
			break;
		case 38:
			DebugEnterAlt(38);
			// Mini.g:1:198: NOT
			{
			DebugLocation(1, 198);
			mNOT(); 

			}
			break;
		case 39:
			DebugEnterAlt(39);
			// Mini.g:1:202: ID
			{
			DebugLocation(1, 202);
			mID(); 

			}
			break;
		case 40:
			DebugEnterAlt(40);
			// Mini.g:1:205: INTEGER
			{
			DebugLocation(1, 205);
			mINTEGER(); 

			}
			break;
		case 41:
			DebugEnterAlt(41);
			// Mini.g:1:213: WS
			{
			DebugLocation(1, 213);
			mWS(); 

			}
			break;
		case 42:
			DebugEnterAlt(42);
			// Mini.g:1:216: COMMENT
			{
			DebugLocation(1, 216);
			mCOMMENT(); 

			}
			break;

		}

	}


	#region DFA
	DFA6 dfa6;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa6 = new DFA6(this);
	}

	private class DFA6 : DFA
	{
		private const string DFA6_eotS =
			"\x1\xFFFF\xC\x1E\x6\xFFFF\x1\x33\x3\xFFFF\x1\x35\x1\x37\x1\x39\x8\xFFFF"+
			"\x6\x1E\x1\x40\x9\x1E\x8\xFFFF\x5\x1E\x1\x50\x1\xFFFF\x1\x51\x1\x52\x8"+
			"\x1E\x1\x5B\x1\x1E\x1\x5D\x1\x5E\x1\x1E\x3\xFFFF\x1\x60\x1\x1E\x1\x62"+
			"\x2\x1E\x1\x65\x1\x66\x1\x1E\x1\xFFFF\x1\x1E\x2\xFFFF\x1\x69\x1\xFFFF"+
			"\x1\x6A\x1\xFFFF\x2\x1E\x2\xFFFF\x1\x6D\x1\x6E\x2\xFFFF\x1\x6F\x1\x70"+
			"\x4\xFFFF";
		private const string DFA6_eofS =
			"\x71\xFFFF";
		private const string DFA6_minS =
			"\x1\x9\x1\x6F\x1\x65\x1\x6C\x1\x61\x1\x66\x1\x65\x1\x72\x1\x65\x1\x74"+
			"\x1\x72\x1\x6F\x1\x68\x6\xFFFF\x1\x3D\x3\xFFFF\x3\x3D\x8\xFFFF\x1\x6F"+
			"\x1\x6C\x1\x73\x1\x64\x1\x6C\x1\x6E\x1\x30\x1\x74\x1\x77\x1\x6C\x1\x69"+
			"\x1\x61\x1\x72\x1\x75\x2\x69\x8\xFFFF\x1\x6C\x2\x65\x1\x6C\x1\x73\x1"+
			"\x30\x1\xFFFF\x2\x30\x1\x6C\x1\x6E\x1\x64\x2\x75\x1\x65\x1\x64\x1\x6C"+
			"\x1\x30\x1\x74\x2\x30\x1\x65\x3\xFFFF\x1\x30\x1\x74\x1\x30\x1\x72\x1"+
			"\x63\x2\x30\x1\x65\x1\xFFFF\x1\x65\x2\xFFFF\x1\x30\x1\xFFFF\x1\x30\x1"+
			"\xFFFF\x1\x6E\x1\x74\x2\xFFFF\x2\x30\x2\xFFFF\x2\x30\x4\xFFFF";
		private const string DFA6_maxS =
			"\x1\x7D\x1\x6F\x1\x65\x1\x6E\x1\x75\x1\x6E\x1\x75\x1\x72\x1\x65\x1\x74"+
			"\x1\x72\x1\x6F\x1\x68\x6\xFFFF\x1\x3D\x3\xFFFF\x3\x3D\x8\xFFFF\x1\x6F"+
			"\x1\x6C\x1\x73\x1\x64\x1\x6C\x1\x6E\x1\x7A\x1\x74\x1\x77\x1\x6C\x1\x69"+
			"\x1\x74\x1\x72\x1\x75\x2\x69\x8\xFFFF\x1\x6C\x2\x65\x1\x6C\x1\x73\x1"+
			"\x7A\x1\xFFFF\x2\x7A\x1\x6C\x1\x6E\x1\x64\x2\x75\x1\x65\x1\x64\x1\x6C"+
			"\x1\x7A\x1\x74\x2\x7A\x1\x65\x3\xFFFF\x1\x7A\x1\x74\x1\x7A\x1\x72\x1"+
			"\x63\x2\x7A\x1\x65\x1\xFFFF\x1\x65\x2\xFFFF\x1\x7A\x1\xFFFF\x1\x7A\x1"+
			"\xFFFF\x1\x6E\x1\x74\x2\xFFFF\x2\x7A\x2\xFFFF\x2\x7A\x4\xFFFF";
		private const string DFA6_acceptS =
			"\xD\xFFFF\x1\x12\x1\x13\x1\x14\x1\x15\x1\x16\x1\x17\x1\xFFFF\x1\x19\x1"+
			"\x1A\x1\x1B\x3\xFFFF\x1\x22\x1\x23\x1\x24\x1\x25\x1\x27\x1\x28\x1\x29"+
			"\x1\x2A\x10\xFFFF\x1\x1C\x1\x18\x1\x20\x1\x1D\x1\x21\x1\x1E\x1\x1F\x1"+
			"\x26\x6\xFFFF\x1\x7\xF\xFFFF\x1\x6\x1\x8\x1\x9\x8\xFFFF\x1\x1\x1\xFFFF"+
			"\x1\x3\x1\x4\x1\xFFFF\x1\xA\x1\xFFFF\x1\xC\x2\xFFFF\x1\xF\x1\x10\x2\xFFFF"+
			"\x1\x5\x1\xB\x2\xFFFF\x1\x11\x1\x2\x1\xD\x1\xE";
		private const string DFA6_specialS =
			"\x71\xFFFF}>";
		private static readonly string[] DFA6_transitionS =
			{
				"\x2\x20\x1\xFFFF\x2\x20\x12\xFFFF\x1\x20\x1\x19\x1\xFFFF\x1\x21\x2\xFFFF"+
				"\x1\x15\x1\xFFFF\x1\x11\x1\x12\x1\x1C\x1\x1A\x1\x10\x1\x1B\x1\x14\x1"+
				"\x1D\xA\x1F\x1\xFFFF\x1\xF\x1\x17\x1\x13\x1\x18\x2\xFFFF\x1A\x1E\x6"+
				"\xFFFF\x1\x1E\x1\x1\x1\x1E\x1\x2\x1\x3\x1\x4\x2\x1E\x1\x5\x4\x1E\x1"+
				"\x6\x1\x1E\x1\x7\x1\x1E\x1\x8\x1\x9\x1\xA\x1\x1E\x1\xB\x1\xC\x3\x1E"+
				"\x1\xD\x1\x16\x1\xE",
				"\x1\x22",
				"\x1\x23",
				"\x1\x24\x1\xFFFF\x1\x25",
				"\x1\x26\x13\xFFFF\x1\x27",
				"\x1\x28\x7\xFFFF\x1\x29",
				"\x1\x2A\xF\xFFFF\x1\x2B",
				"\x1\x2C",
				"\x1\x2D",
				"\x1\x2E",
				"\x1\x2F",
				"\x1\x30",
				"\x1\x31",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x32",
				"",
				"",
				"",
				"\x1\x34",
				"\x1\x36",
				"\x1\x38",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x3A",
				"\x1\x3B",
				"\x1\x3C",
				"\x1\x3D",
				"\x1\x3E",
				"\x1\x3F",
				"\xA\x1E\x7\xFFFF\x1A\x1E\x6\xFFFF\x1A\x1E",
				"\x1\x41",
				"\x1\x42",
				"\x1\x43",
				"\x1\x44",
				"\x1\x45\x12\xFFFF\x1\x46",
				"\x1\x47",
				"\x1\x48",
				"\x1\x49",
				"\x1\x4A",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x4B",
				"\x1\x4C",
				"\x1\x4D",
				"\x1\x4E",
				"\x1\x4F",
				"\xA\x1E\x7\xFFFF\x1A\x1E\x6\xFFFF\x1A\x1E",
				"",
				"\xA\x1E\x7\xFFFF\x1A\x1E\x6\xFFFF\x1A\x1E",
				"\xA\x1E\x7\xFFFF\x1A\x1E\x6\xFFFF\x1A\x1E",
				"\x1\x53",
				"\x1\x54",
				"\x1\x55",
				"\x1\x56",
				"\x1\x57",
				"\x1\x58",
				"\x1\x59",
				"\x1\x5A",
				"\xA\x1E\x7\xFFFF\x1A\x1E\x6\xFFFF\x1A\x1E",
				"\x1\x5C",
				"\xA\x1E\x7\xFFFF\x1A\x1E\x6\xFFFF\x1A\x1E",
				"\xA\x1E\x7\xFFFF\x1A\x1E\x6\xFFFF\x1A\x1E",
				"\x1\x5F",
				"",
				"",
				"",
				"\xA\x1E\x7\xFFFF\x1A\x1E\x6\xFFFF\x1A\x1E",
				"\x1\x61",
				"\xA\x1E\x7\xFFFF\x1A\x1E\x6\xFFFF\x1A\x1E",
				"\x1\x63",
				"\x1\x64",
				"\xA\x1E\x7\xFFFF\x1A\x1E\x6\xFFFF\x1A\x1E",
				"\xA\x1E\x7\xFFFF\x1A\x1E\x6\xFFFF\x1A\x1E",
				"\x1\x67",
				"",
				"\x1\x68",
				"",
				"",
				"\xA\x1E\x7\xFFFF\x1A\x1E\x6\xFFFF\x1A\x1E",
				"",
				"\xA\x1E\x7\xFFFF\x1A\x1E\x6\xFFFF\x1A\x1E",
				"",
				"\x1\x6B",
				"\x1\x6C",
				"",
				"",
				"\xA\x1E\x7\xFFFF\x1A\x1E\x6\xFFFF\x1A\x1E",
				"\xA\x1E\x7\xFFFF\x1A\x1E\x6\xFFFF\x1A\x1E",
				"",
				"",
				"\xA\x1E\x7\xFFFF\x1A\x1E\x6\xFFFF\x1A\x1E",
				"\xA\x1E\x7\xFFFF\x1A\x1E\x6\xFFFF\x1A\x1E",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA6_eot = DFA.UnpackEncodedString(DFA6_eotS);
		private static readonly short[] DFA6_eof = DFA.UnpackEncodedString(DFA6_eofS);
		private static readonly char[] DFA6_min = DFA.UnpackEncodedStringToUnsignedChars(DFA6_minS);
		private static readonly char[] DFA6_max = DFA.UnpackEncodedStringToUnsignedChars(DFA6_maxS);
		private static readonly short[] DFA6_accept = DFA.UnpackEncodedString(DFA6_acceptS);
		private static readonly short[] DFA6_special = DFA.UnpackEncodedString(DFA6_specialS);
		private static readonly short[][] DFA6_transition;

		static DFA6()
		{
			int numStates = DFA6_transitionS.Length;
			DFA6_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA6_transition[i] = DFA.UnpackEncodedString(DFA6_transitionS[i]);
			}
		}

		public DFA6( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 6;
			this.eot = DFA6_eot;
			this.eof = DFA6_eof;
			this.min = DFA6_min;
			this.max = DFA6_max;
			this.accept = DFA6_accept;
			this.special = DFA6_special;
			this.transition = DFA6_transition;
		}

		public override string Description { get { return "1:1: Tokens : ( BOOL | DELETE | ELSE | ENDL | FALSE | FUN | IF | INT | NEW | NULL | PRINT | READ | RETURN | STRUCT | TRUE | VOID | WHILE | LBRACE | RBRACE | SEMI | COMMA | LPAREN | RPAREN | ASSIGN | DOT | AND | OR | EQ | LT | GT | NE | LE | GE | PLUS | MINUS | TIMES | DIVIDE | NOT | ID | INTEGER | WS | COMMENT );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion

}
