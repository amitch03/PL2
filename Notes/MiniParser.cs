//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.2 Mini.g 2014-11-13 16:55:49

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019



using System;



using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.2")]
[System.CLSCompliant(false)]
public partial class MiniParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AND", "ARGS", "ASSIGN", "BLOCK", "BOOL", "COMMA", "COMMENT", "DECL", "DECLLIST", "DECLS", "DELETE", "DIVIDE", "DOT", "ELSE", "ENDL", "EQ", "FALSE", "FUN", "FUNCS", "GE", "GT", "ID", "IF", "INT", "INTEGER", "INVOKE", "LBRACE", "LE", "LPAREN", "LT", "MINUS", "NE", "NEG", "NEW", "NOT", "NULL", "OR", "PARAMS", "PLUS", "PRINT", "PROGRAM", "RBRACE", "READ", "RETTYPE", "RETURN", "RPAREN", "SEMI", "STMTS", "STRUCT", "TIMES", "TRUE", "TYPE", "TYPES", "VOID", "WHILE", "WS"
	};
	public const int EOF=-1;
	public const int AND=4;
	public const int ARGS=5;
	public const int ASSIGN=6;
	public const int BLOCK=7;
	public const int BOOL=8;
	public const int COMMA=9;
	public const int COMMENT=10;
	public const int DECL=11;
	public const int DECLLIST=12;
	public const int DECLS=13;
	public const int DELETE=14;
	public const int DIVIDE=15;
	public const int DOT=16;
	public const int ELSE=17;
	public const int ENDL=18;
	public const int EQ=19;
	public const int FALSE=20;
	public const int FUN=21;
	public const int FUNCS=22;
	public const int GE=23;
	public const int GT=24;
	public const int ID=25;
	public const int IF=26;
	public const int INT=27;
	public const int INTEGER=28;
	public const int INVOKE=29;
	public const int LBRACE=30;
	public const int LE=31;
	public const int LPAREN=32;
	public const int LT=33;
	public const int MINUS=34;
	public const int NE=35;
	public const int NEG=36;
	public const int NEW=37;
	public const int NOT=38;
	public const int NULL=39;
	public const int OR=40;
	public const int PARAMS=41;
	public const int PLUS=42;
	public const int PRINT=43;
	public const int PROGRAM=44;
	public const int RBRACE=45;
	public const int READ=46;
	public const int RETTYPE=47;
	public const int RETURN=48;
	public const int RPAREN=49;
	public const int SEMI=50;
	public const int STMTS=51;
	public const int STRUCT=52;
	public const int TIMES=53;
	public const int TRUE=54;
	public const int TYPE=55;
	public const int TYPES=56;
	public const int VOID=57;
	public const int WHILE=58;
	public const int WS=59;

	public MiniParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public MiniParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return MiniParser.tokenNames; } }
	public override string GrammarFileName { get { return "Mini.g"; } }



	public CommonTree ParseProgram()
	{
	   var scope = program();
	   return (CommonTree)scope.Tree;
	}

	public static bool _errors = false;

	public static void reportError(RecognitionException recognitionException)
	{
	   Console.WriteLine("error: {0}", recognitionException);
	}

	public static void recover(ITokenStream input, RecognitionException recognitionException)
	{
	}

	// ***********************************************************************************************************



	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();
	// $ANTLR start "program"
	// Mini.g:138:1: program : t= types d= declarations f= functions EOF -> ^( PROGRAM $t $d $f) ;
	[GrammarRule("program")]
	private AstParserRuleReturnScope<object, IToken> program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EOF1 = default(IToken);
		AstParserRuleReturnScope<object, IToken> t = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> d = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> f = default(AstParserRuleReturnScope<object, IToken>);

		object EOF1_tree = default(object);
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_types=new RewriteRuleSubtreeStream(adaptor,"rule types");
		RewriteRuleSubtreeStream stream_declarations=new RewriteRuleSubtreeStream(adaptor,"rule declarations");
		RewriteRuleSubtreeStream stream_functions=new RewriteRuleSubtreeStream(adaptor,"rule functions");
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(138, 3);
		try
		{
			// Mini.g:139:4: (t= types d= declarations f= functions EOF -> ^( PROGRAM $t $d $f) )
			DebugEnterAlt(1);
			// Mini.g:139:7: t= types d= declarations f= functions EOF
			{
			DebugLocation(139, 8);
			PushFollow(Follow._types_in_program1057);
			t=types();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_types.Add(t.Tree);
			DebugLocation(139, 16);
			PushFollow(Follow._declarations_in_program1061);
			d=declarations();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_declarations.Add(d.Tree);
			DebugLocation(139, 31);
			PushFollow(Follow._functions_in_program1065);
			f=functions();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_functions.Add(f.Tree);
			DebugLocation(139, 42);
			EOF1=(IToken)Match(input,EOF,Follow._EOF_in_program1067); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EOF.Add(EOF1);



			{
			// AST REWRITE
			// elements: t, d, f
			// token labels: 
			// rule labels: t, d, f, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_t=new RewriteRuleSubtreeStream(adaptor,"rule t",t!=null?t.Tree:null);
			RewriteRuleSubtreeStream stream_d=new RewriteRuleSubtreeStream(adaptor,"rule d",d!=null?d.Tree:null);
			RewriteRuleSubtreeStream stream_f=new RewriteRuleSubtreeStream(adaptor,"rule f",f!=null?f.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 140:7: -> ^( PROGRAM $t $d $f)
			{
				DebugLocation(140, 10);
				// Mini.g:140:10: ^( PROGRAM $t $d $f)
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(140, 12);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PROGRAM, "PROGRAM"), root_1);

				DebugLocation(140, 21);
				adaptor.AddChild(root_1, stream_t.NextTree());
				DebugLocation(140, 24);
				adaptor.AddChild(root_1, stream_d.NextTree());
				DebugLocation(140, 27);
				adaptor.AddChild(root_1, stream_f.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(141, 3);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_types();
	partial void LeaveRule_types();
	// $ANTLR start "types"
	// Mini.g:142:1: types : ( ( STRUCT ID LBRACE )=> types_sub -> ^( TYPES types_sub ) | -> TYPES );
	[GrammarRule("types")]
	private AstParserRuleReturnScope<object, IToken> types()
	{
		EnterRule_types();
		EnterRule("types", 2);
		TraceIn("types", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> types_sub2 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_types_sub=new RewriteRuleSubtreeStream(adaptor,"rule types_sub");
		try { DebugEnterRule(GrammarFileName, "types");
		DebugLocation(142, 3);
		try
		{
			// Mini.g:143:4: ( ( STRUCT ID LBRACE )=> types_sub -> ^( TYPES types_sub ) | -> TYPES )
			int alt1=2;
			try { DebugEnterDecision(1, false);
			switch (input.LA(1))
			{
			case STRUCT:
				{
				int LA1_2 = input.LA(2);

				if ((EvaluatePredicate(synpred1_Mini_fragment)))
				{
					alt1 = 1;
				}
				else if ((true))
				{
					alt1 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 1, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case INT:
				{
				int LA1_2 = input.LA(2);

				if ((EvaluatePredicate(synpred1_Mini_fragment)))
				{
					alt1 = 1;
				}
				else if ((true))
				{
					alt1 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 1, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case BOOL:
				{
				int LA1_2 = input.LA(2);

				if ((EvaluatePredicate(synpred1_Mini_fragment)))
				{
					alt1 = 1;
				}
				else if ((true))
				{
					alt1 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 1, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case FUN:
				{
				int LA1_2 = input.LA(2);

				if ((EvaluatePredicate(synpred1_Mini_fragment)))
				{
					alt1 = 1;
				}
				else if ((true))
				{
					alt1 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 1, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case EOF:
				{
				int LA1_2 = input.LA(2);

				if ((EvaluatePredicate(synpred1_Mini_fragment)))
				{
					alt1 = 1;
				}
				else if ((true))
				{
					alt1 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 1, 5, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 1, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// Mini.g:143:7: ( STRUCT ID LBRACE )=> types_sub
				{
				DebugLocation(143, 29);
				PushFollow(Follow._types_sub_in_types1113);
				types_sub2=types_sub();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_types_sub.Add(types_sub2.Tree);


				{
				// AST REWRITE
				// elements: types_sub
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 143:39: -> ^( TYPES types_sub )
				{
					DebugLocation(143, 42);
					// Mini.g:143:42: ^( TYPES types_sub )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(143, 44);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(TYPES, "TYPES"), root_1);

					DebugLocation(143, 50);
					adaptor.AddChild(root_1, stream_types_sub.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Mini.g:144:7: 
				{

				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 144:7: -> TYPES
				{
					DebugLocation(144, 10);
					adaptor.AddChild(root_0, (object)adaptor.Create(TYPES, "TYPES"));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("types", 2);
			LeaveRule("types", 2);
			LeaveRule_types();
		}
		DebugLocation(145, 3);
		} finally { DebugExitRule(GrammarFileName, "types"); }
		return retval;

	}
	// $ANTLR end "types"

	partial void EnterRule_types_sub();
	partial void LeaveRule_types_sub();
	// $ANTLR start "types_sub"
	// Mini.g:146:1: types_sub : ( ( STRUCT ID LBRACE )=> type_declaration types_sub |);
	[GrammarRule("types_sub")]
	private AstParserRuleReturnScope<object, IToken> types_sub()
	{
		EnterRule_types_sub();
		EnterRule("types_sub", 3);
		TraceIn("types_sub", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> type_declaration3 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> types_sub4 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "types_sub");
		DebugLocation(146, 3);
		try
		{
			// Mini.g:147:4: ( ( STRUCT ID LBRACE )=> type_declaration types_sub |)
			int alt2=2;
			try { DebugEnterDecision(2, false);
			int LA2_1 = input.LA(1);

			if ((LA2_1==STRUCT))
			{
				int LA2_2 = input.LA(2);

				if ((LA2_2==ID))
				{
					int LA2_3 = input.LA(3);

					if ((LA2_3==LBRACE) && (EvaluatePredicate(synpred2_Mini_fragment)))
					{
						alt2 = 1;
					}
					else if ((LA2_3==ID))
					{
						alt2 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 2, 3, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 2, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA2_1==EOF||LA2_1==BOOL||LA2_1==FUN||LA2_1==INT))
			{
				alt2 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 2, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// Mini.g:147:7: ( STRUCT ID LBRACE )=> type_declaration types_sub
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(147, 29);
				PushFollow(Follow._type_declaration_in_types_sub1156);
				type_declaration3=type_declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, type_declaration3.Tree);
				DebugLocation(147, 46);
				PushFollow(Follow._types_sub_in_types_sub1158);
				types_sub4=types_sub();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, types_sub4.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Mini.g:149:4: 
				{
				root_0 = (object)adaptor.Nil();

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("types_sub", 3);
			LeaveRule("types_sub", 3);
			LeaveRule_types_sub();
		}
		DebugLocation(149, 3);
		} finally { DebugExitRule(GrammarFileName, "types_sub"); }
		return retval;

	}
	// $ANTLR end "types_sub"

	partial void EnterRule_type_declaration();
	partial void LeaveRule_type_declaration();
	// $ANTLR start "type_declaration"
	// Mini.g:150:1: type_declaration : STRUCT ^ ID LBRACE ! nested_decl RBRACE ! SEMI !;
	[GrammarRule("type_declaration")]
	private AstParserRuleReturnScope<object, IToken> type_declaration()
	{
		EnterRule_type_declaration();
		EnterRule("type_declaration", 4);
		TraceIn("type_declaration", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken STRUCT5 = default(IToken);
		IToken ID6 = default(IToken);
		IToken LBRACE7 = default(IToken);
		IToken RBRACE9 = default(IToken);
		IToken SEMI10 = default(IToken);
		AstParserRuleReturnScope<object, IToken> nested_decl8 = default(AstParserRuleReturnScope<object, IToken>);

		object STRUCT5_tree = default(object);
		object ID6_tree = default(object);
		object LBRACE7_tree = default(object);
		object RBRACE9_tree = default(object);
		object SEMI10_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "type_declaration");
		DebugLocation(150, 3);
		try
		{
			// Mini.g:151:4: ( STRUCT ^ ID LBRACE ! nested_decl RBRACE ! SEMI !)
			DebugEnterAlt(1);
			// Mini.g:151:7: STRUCT ^ ID LBRACE ! nested_decl RBRACE ! SEMI !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(151, 13);
			STRUCT5=(IToken)Match(input,STRUCT,Follow._STRUCT_in_type_declaration1178); if (state.failed) return retval;
			if (state.backtracking == 0) {
			STRUCT5_tree = (object)adaptor.Create(STRUCT5);
			root_0 = (object)adaptor.BecomeRoot(STRUCT5_tree, root_0);
			}
			DebugLocation(151, 15);
			ID6=(IToken)Match(input,ID,Follow._ID_in_type_declaration1181); if (state.failed) return retval;
			if (state.backtracking == 0) {
			ID6_tree = (object)adaptor.Create(ID6);
			adaptor.AddChild(root_0, ID6_tree);
			}
			DebugLocation(151, 24);
			LBRACE7=(IToken)Match(input,LBRACE,Follow._LBRACE_in_type_declaration1183); if (state.failed) return retval;
			DebugLocation(151, 26);
			PushFollow(Follow._nested_decl_in_type_declaration1186);
			nested_decl8=nested_decl();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, nested_decl8.Tree);
			DebugLocation(151, 44);
			RBRACE9=(IToken)Match(input,RBRACE,Follow._RBRACE_in_type_declaration1188); if (state.failed) return retval;
			DebugLocation(151, 50);
			SEMI10=(IToken)Match(input,SEMI,Follow._SEMI_in_type_declaration1191); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("type_declaration", 4);
			LeaveRule("type_declaration", 4);
			LeaveRule_type_declaration();
		}
		DebugLocation(152, 3);
		} finally { DebugExitRule(GrammarFileName, "type_declaration"); }
		return retval;

	}
	// $ANTLR end "type_declaration"

	partial void EnterRule_nested_decl();
	partial void LeaveRule_nested_decl();
	// $ANTLR start "nested_decl"
	// Mini.g:153:1: nested_decl : ( decl SEMI !)+ ;
	[GrammarRule("nested_decl")]
	private AstParserRuleReturnScope<object, IToken> nested_decl()
	{
		EnterRule_nested_decl();
		EnterRule("nested_decl", 5);
		TraceIn("nested_decl", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken SEMI12 = default(IToken);
		AstParserRuleReturnScope<object, IToken> decl11 = default(AstParserRuleReturnScope<object, IToken>);

		object SEMI12_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "nested_decl");
		DebugLocation(153, 3);
		try
		{
			// Mini.g:154:4: ( ( decl SEMI !)+ )
			DebugEnterAlt(1);
			// Mini.g:154:7: ( decl SEMI !)+
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(154, 7);
			// Mini.g:154:7: ( decl SEMI !)+
			int cnt3=0;
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_1 = input.LA(1);

				if ((LA3_1==BOOL||LA3_1==INT||LA3_1==STRUCT))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch (alt3)
				{
				case 1:
					DebugEnterAlt(1);
					// Mini.g:154:8: decl SEMI !
					{
					DebugLocation(154, 8);
					PushFollow(Follow._decl_in_nested_decl1208);
					decl11=decl();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, decl11.Tree);
					DebugLocation(154, 17);
					SEMI12=(IToken)Match(input,SEMI,Follow._SEMI_in_nested_decl1210); if (state.failed) return retval;

					}
					break;

				default:
					if (cnt3 >= 1)
						goto loop3;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee3 = new EarlyExitException( 3, input );
					DebugRecognitionException(eee3);
					throw eee3;
				}
				cnt3++;
			}
			loop3:
				;

			} finally { DebugExitSubRule(3); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("nested_decl", 5);
			LeaveRule("nested_decl", 5);
			LeaveRule_nested_decl();
		}
		DebugLocation(155, 3);
		} finally { DebugExitRule(GrammarFileName, "nested_decl"); }
		return retval;

	}
	// $ANTLR end "nested_decl"

	partial void EnterRule_decl();
	partial void LeaveRule_decl();
	// $ANTLR start "decl"
	// Mini.g:156:1: decl : t= type i= ID -> ^( DECL ^( TYPE $t) $i) ;
	[GrammarRule("decl")]
	private AstParserRuleReturnScope<object, IToken> decl()
	{
		EnterRule_decl();
		EnterRule("decl", 6);
		TraceIn("decl", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken i = default(IToken);
		AstParserRuleReturnScope<object, IToken> t = default(AstParserRuleReturnScope<object, IToken>);

		object i_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		try { DebugEnterRule(GrammarFileName, "decl");
		DebugLocation(156, 3);
		try
		{
			// Mini.g:157:4: (t= type i= ID -> ^( DECL ^( TYPE $t) $i) )
			DebugEnterAlt(1);
			// Mini.g:157:7: t= type i= ID
			{
			DebugLocation(157, 8);
			PushFollow(Follow._type_in_decl1230);
			t=type();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_type.Add(t.Tree);
			DebugLocation(157, 15);
			i=(IToken)Match(input,ID,Follow._ID_in_decl1234); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(i);



			{
			// AST REWRITE
			// elements: t, i
			// token labels: i
			// rule labels: t, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_i=new RewriteRuleITokenStream(adaptor,"token i",i);
			RewriteRuleSubtreeStream stream_t=new RewriteRuleSubtreeStream(adaptor,"rule t",t!=null?t.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 158:7: -> ^( DECL ^( TYPE $t) $i)
			{
				DebugLocation(158, 10);
				// Mini.g:158:10: ^( DECL ^( TYPE $t) $i)
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(158, 12);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(DECL, "DECL"), root_1);

				DebugLocation(158, 17);
				// Mini.g:158:17: ^( TYPE $t)
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(158, 19);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(TYPE, "TYPE"), root_2);

				DebugLocation(158, 25);
				adaptor.AddChild(root_2, stream_t.NextTree());

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(158, 29);
				adaptor.AddChild(root_1, stream_i.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("decl", 6);
			LeaveRule("decl", 6);
			LeaveRule_decl();
		}
		DebugLocation(159, 3);
		} finally { DebugExitRule(GrammarFileName, "decl"); }
		return retval;

	}
	// $ANTLR end "decl"

	partial void EnterRule_type();
	partial void LeaveRule_type();
	// $ANTLR start "type"
	// Mini.g:160:1: type : ( INT | BOOL | STRUCT ^ ID );
	[GrammarRule("type")]
	private AstParserRuleReturnScope<object, IToken> type()
	{
		EnterRule_type();
		EnterRule("type", 7);
		TraceIn("type", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken INT13 = default(IToken);
		IToken BOOL14 = default(IToken);
		IToken STRUCT15 = default(IToken);
		IToken ID16 = default(IToken);

		object INT13_tree = default(object);
		object BOOL14_tree = default(object);
		object STRUCT15_tree = default(object);
		object ID16_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "type");
		DebugLocation(160, 3);
		try
		{
			// Mini.g:161:4: ( INT | BOOL | STRUCT ^ ID )
			int alt4=3;
			try { DebugEnterDecision(4, false);
			switch (input.LA(1))
			{
			case INT:
				{
				alt4 = 1;
				}
				break;
			case BOOL:
				{
				alt4 = 2;
				}
				break;
			case STRUCT:
				{
				alt4 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 4, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// Mini.g:161:7: INT
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(161, 7);
				INT13=(IToken)Match(input,INT,Follow._INT_in_type1271); if (state.failed) return retval;
				if (state.backtracking == 0) {
				INT13_tree = (object)adaptor.Create(INT13);
				adaptor.AddChild(root_0, INT13_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Mini.g:162:7: BOOL
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(162, 7);
				BOOL14=(IToken)Match(input,BOOL,Follow._BOOL_in_type1279); if (state.failed) return retval;
				if (state.backtracking == 0) {
				BOOL14_tree = (object)adaptor.Create(BOOL14);
				adaptor.AddChild(root_0, BOOL14_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Mini.g:163:7: STRUCT ^ ID
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(163, 13);
				STRUCT15=(IToken)Match(input,STRUCT,Follow._STRUCT_in_type1287); if (state.failed) return retval;
				if (state.backtracking == 0) {
				STRUCT15_tree = (object)adaptor.Create(STRUCT15);
				root_0 = (object)adaptor.BecomeRoot(STRUCT15_tree, root_0);
				}
				DebugLocation(163, 15);
				ID16=(IToken)Match(input,ID,Follow._ID_in_type1290); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ID16_tree = (object)adaptor.Create(ID16);
				adaptor.AddChild(root_0, ID16_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("type", 7);
			LeaveRule("type", 7);
			LeaveRule_type();
		}
		DebugLocation(164, 3);
		} finally { DebugExitRule(GrammarFileName, "type"); }
		return retval;

	}
	// $ANTLR end "type"

	partial void EnterRule_declarations();
	partial void LeaveRule_declarations();
	// $ANTLR start "declarations"
	// Mini.g:165:1: declarations : ( declaration )* -> ^( DECLS ( declaration )* ) ;
	[GrammarRule("declarations")]
	private AstParserRuleReturnScope<object, IToken> declarations()
	{
		EnterRule_declarations();
		EnterRule("declarations", 8);
		TraceIn("declarations", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> declaration17 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_declaration=new RewriteRuleSubtreeStream(adaptor,"rule declaration");
		try { DebugEnterRule(GrammarFileName, "declarations");
		DebugLocation(165, 3);
		try
		{
			// Mini.g:166:4: ( ( declaration )* -> ^( DECLS ( declaration )* ) )
			DebugEnterAlt(1);
			// Mini.g:166:7: ( declaration )*
			{
			DebugLocation(166, 7);
			// Mini.g:166:7: ( declaration )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_1 = input.LA(1);

				if ((LA5_1==BOOL||LA5_1==INT||LA5_1==STRUCT))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// Mini.g:166:8: declaration
					{
					DebugLocation(166, 8);
					PushFollow(Follow._declaration_in_declarations1306);
					declaration17=declaration();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_declaration.Add(declaration17.Tree);

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }



			{
			// AST REWRITE
			// elements: declaration
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 166:22: -> ^( DECLS ( declaration )* )
			{
				DebugLocation(166, 25);
				// Mini.g:166:25: ^( DECLS ( declaration )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(166, 27);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(DECLS, "DECLS"), root_1);

				DebugLocation(166, 33);
				// Mini.g:166:33: ( declaration )*
				while ( stream_declaration.HasNext )
				{
					DebugLocation(166, 33);
					adaptor.AddChild(root_1, stream_declaration.NextTree());

				}
				stream_declaration.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("declarations", 8);
			LeaveRule("declarations", 8);
			LeaveRule_declarations();
		}
		DebugLocation(167, 3);
		} finally { DebugExitRule(GrammarFileName, "declarations"); }
		return retval;

	}
	// $ANTLR end "declarations"

	partial void EnterRule_declaration();
	partial void LeaveRule_declaration();
	// $ANTLR start "declaration"
	// Mini.g:168:1: declaration : t= type ilist= id_list SEMI -> ^( DECLLIST ^( TYPE $t) $ilist) ;
	[GrammarRule("declaration")]
	private AstParserRuleReturnScope<object, IToken> declaration()
	{
		EnterRule_declaration();
		EnterRule("declaration", 9);
		TraceIn("declaration", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken SEMI18 = default(IToken);
		AstParserRuleReturnScope<object, IToken> t = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> ilist = default(AstParserRuleReturnScope<object, IToken>);

		object SEMI18_tree = default(object);
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		RewriteRuleSubtreeStream stream_id_list=new RewriteRuleSubtreeStream(adaptor,"rule id_list");
		try { DebugEnterRule(GrammarFileName, "declaration");
		DebugLocation(168, 3);
		try
		{
			// Mini.g:169:4: (t= type ilist= id_list SEMI -> ^( DECLLIST ^( TYPE $t) $ilist) )
			DebugEnterAlt(1);
			// Mini.g:169:7: t= type ilist= id_list SEMI
			{
			DebugLocation(169, 8);
			PushFollow(Follow._type_in_declaration1334);
			t=type();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_type.Add(t.Tree);
			DebugLocation(169, 19);
			PushFollow(Follow._id_list_in_declaration1338);
			ilist=id_list();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_id_list.Add(ilist.Tree);
			DebugLocation(169, 28);
			SEMI18=(IToken)Match(input,SEMI,Follow._SEMI_in_declaration1340); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI18);



			{
			// AST REWRITE
			// elements: t, ilist
			// token labels: 
			// rule labels: t, ilist, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_t=new RewriteRuleSubtreeStream(adaptor,"rule t",t!=null?t.Tree:null);
			RewriteRuleSubtreeStream stream_ilist=new RewriteRuleSubtreeStream(adaptor,"rule ilist",ilist!=null?ilist.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 170:7: -> ^( DECLLIST ^( TYPE $t) $ilist)
			{
				DebugLocation(170, 10);
				// Mini.g:170:10: ^( DECLLIST ^( TYPE $t) $ilist)
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(170, 12);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(DECLLIST, "DECLLIST"), root_1);

				DebugLocation(170, 21);
				// Mini.g:170:21: ^( TYPE $t)
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(170, 23);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(TYPE, "TYPE"), root_2);

				DebugLocation(170, 29);
				adaptor.AddChild(root_2, stream_t.NextTree());

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(170, 33);
				adaptor.AddChild(root_1, stream_ilist.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("declaration", 9);
			LeaveRule("declaration", 9);
			LeaveRule_declaration();
		}
		DebugLocation(171, 3);
		} finally { DebugExitRule(GrammarFileName, "declaration"); }
		return retval;

	}
	// $ANTLR end "declaration"

	partial void EnterRule_id_list();
	partial void LeaveRule_id_list();
	// $ANTLR start "id_list"
	// Mini.g:172:1: id_list : ID ( COMMA ! ID )* ;
	[GrammarRule("id_list")]
	private AstParserRuleReturnScope<object, IToken> id_list()
	{
		EnterRule_id_list();
		EnterRule("id_list", 10);
		TraceIn("id_list", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID19 = default(IToken);
		IToken COMMA20 = default(IToken);
		IToken ID21 = default(IToken);

		object ID19_tree = default(object);
		object COMMA20_tree = default(object);
		object ID21_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "id_list");
		DebugLocation(172, 3);
		try
		{
			// Mini.g:173:4: ( ID ( COMMA ! ID )* )
			DebugEnterAlt(1);
			// Mini.g:173:7: ID ( COMMA ! ID )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(173, 7);
			ID19=(IToken)Match(input,ID,Follow._ID_in_id_list1377); if (state.failed) return retval;
			if (state.backtracking == 0) {
			ID19_tree = (object)adaptor.Create(ID19);
			adaptor.AddChild(root_0, ID19_tree);
			}
			DebugLocation(173, 10);
			// Mini.g:173:10: ( COMMA ! ID )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_1 = input.LA(1);

				if ((LA6_1==COMMA))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// Mini.g:173:11: COMMA ! ID
					{
					DebugLocation(173, 16);
					COMMA20=(IToken)Match(input,COMMA,Follow._COMMA_in_id_list1380); if (state.failed) return retval;
					DebugLocation(173, 18);
					ID21=(IToken)Match(input,ID,Follow._ID_in_id_list1383); if (state.failed) return retval;
					if (state.backtracking == 0) {
					ID21_tree = (object)adaptor.Create(ID21);
					adaptor.AddChild(root_0, ID21_tree);
					}

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("id_list", 10);
			LeaveRule("id_list", 10);
			LeaveRule_id_list();
		}
		DebugLocation(174, 3);
		} finally { DebugExitRule(GrammarFileName, "id_list"); }
		return retval;

	}
	// $ANTLR end "id_list"

	partial void EnterRule_functions();
	partial void LeaveRule_functions();
	// $ANTLR start "functions"
	// Mini.g:175:1: functions : ( function )* -> ^( FUNCS ( function )* ) ;
	[GrammarRule("functions")]
	private AstParserRuleReturnScope<object, IToken> functions()
	{
		EnterRule_functions();
		EnterRule("functions", 11);
		TraceIn("functions", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> function22 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_function=new RewriteRuleSubtreeStream(adaptor,"rule function");
		try { DebugEnterRule(GrammarFileName, "functions");
		DebugLocation(175, 3);
		try
		{
			// Mini.g:176:4: ( ( function )* -> ^( FUNCS ( function )* ) )
			DebugEnterAlt(1);
			// Mini.g:176:7: ( function )*
			{
			DebugLocation(176, 7);
			// Mini.g:176:7: ( function )*
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_1 = input.LA(1);

				if ((LA7_1==FUN))
				{
					alt7 = 1;
				}


				} finally { DebugExitDecision(7); }
				switch ( alt7 )
				{
				case 1:
					DebugEnterAlt(1);
					// Mini.g:176:7: function
					{
					DebugLocation(176, 7);
					PushFollow(Follow._function_in_functions1400);
					function22=function();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_function.Add(function22.Tree);

					}
					break;

				default:
					goto loop7;
				}
			}

			loop7:
				;

			} finally { DebugExitSubRule(7); }



			{
			// AST REWRITE
			// elements: function
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 176:17: -> ^( FUNCS ( function )* )
			{
				DebugLocation(176, 20);
				// Mini.g:176:20: ^( FUNCS ( function )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(176, 22);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNCS, "FUNCS"), root_1);

				DebugLocation(176, 28);
				// Mini.g:176:28: ( function )*
				while ( stream_function.HasNext )
				{
					DebugLocation(176, 28);
					adaptor.AddChild(root_1, stream_function.NextTree());

				}
				stream_function.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("functions", 11);
			LeaveRule("functions", 11);
			LeaveRule_functions();
		}
		DebugLocation(177, 3);
		} finally { DebugExitRule(GrammarFileName, "functions"); }
		return retval;

	}
	// $ANTLR end "functions"

	partial void EnterRule_function();
	partial void LeaveRule_function();
	// $ANTLR start "function"
	// Mini.g:178:1: function : FUN id= ID p= parameters r= return_type LBRACE d= declarations s= statement_list RBRACE -> ^( FUN $id $p ^( RETTYPE $r) $d $s) ;
	[GrammarRule("function")]
	private AstParserRuleReturnScope<object, IToken> function()
	{
		EnterRule_function();
		EnterRule("function", 12);
		TraceIn("function", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken id = default(IToken);
		IToken FUN23 = default(IToken);
		IToken LBRACE24 = default(IToken);
		IToken RBRACE25 = default(IToken);
		AstParserRuleReturnScope<object, IToken> p = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> r = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> d = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> s = default(AstParserRuleReturnScope<object, IToken>);

		object id_tree = default(object);
		object FUN23_tree = default(object);
		object LBRACE24_tree = default(object);
		object RBRACE25_tree = default(object);
		RewriteRuleITokenStream stream_FUN=new RewriteRuleITokenStream(adaptor,"token FUN");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_LBRACE=new RewriteRuleITokenStream(adaptor,"token LBRACE");
		RewriteRuleITokenStream stream_RBRACE=new RewriteRuleITokenStream(adaptor,"token RBRACE");
		RewriteRuleSubtreeStream stream_parameters=new RewriteRuleSubtreeStream(adaptor,"rule parameters");
		RewriteRuleSubtreeStream stream_return_type=new RewriteRuleSubtreeStream(adaptor,"rule return_type");
		RewriteRuleSubtreeStream stream_declarations=new RewriteRuleSubtreeStream(adaptor,"rule declarations");
		RewriteRuleSubtreeStream stream_statement_list=new RewriteRuleSubtreeStream(adaptor,"rule statement_list");
		try { DebugEnterRule(GrammarFileName, "function");
		DebugLocation(178, 3);
		try
		{
			// Mini.g:179:4: ( FUN id= ID p= parameters r= return_type LBRACE d= declarations s= statement_list RBRACE -> ^( FUN $id $p ^( RETTYPE $r) $d $s) )
			DebugEnterAlt(1);
			// Mini.g:179:7: FUN id= ID p= parameters r= return_type LBRACE d= declarations s= statement_list RBRACE
			{
			DebugLocation(179, 7);
			FUN23=(IToken)Match(input,FUN,Follow._FUN_in_function1425); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FUN.Add(FUN23);

			DebugLocation(179, 13);
			id=(IToken)Match(input,ID,Follow._ID_in_function1429); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(id);

			DebugLocation(179, 18);
			PushFollow(Follow._parameters_in_function1433);
			p=parameters();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_parameters.Add(p.Tree);
			DebugLocation(179, 31);
			PushFollow(Follow._return_type_in_function1437);
			r=return_type();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_return_type.Add(r.Tree);
			DebugLocation(179, 44);
			LBRACE24=(IToken)Match(input,LBRACE,Follow._LBRACE_in_function1439); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LBRACE.Add(LBRACE24);

			DebugLocation(179, 52);
			PushFollow(Follow._declarations_in_function1443);
			d=declarations();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_declarations.Add(d.Tree);
			DebugLocation(179, 67);
			PushFollow(Follow._statement_list_in_function1447);
			s=statement_list();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statement_list.Add(s.Tree);
			DebugLocation(179, 83);
			RBRACE25=(IToken)Match(input,RBRACE,Follow._RBRACE_in_function1449); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RBRACE.Add(RBRACE25);



			{
			// AST REWRITE
			// elements: FUN, id, p, r, d, s
			// token labels: id
			// rule labels: p, r, d, s, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_id=new RewriteRuleITokenStream(adaptor,"token id",id);
			RewriteRuleSubtreeStream stream_p=new RewriteRuleSubtreeStream(adaptor,"rule p",p!=null?p.Tree:null);
			RewriteRuleSubtreeStream stream_r=new RewriteRuleSubtreeStream(adaptor,"rule r",r!=null?r.Tree:null);
			RewriteRuleSubtreeStream stream_d=new RewriteRuleSubtreeStream(adaptor,"rule d",d!=null?d.Tree:null);
			RewriteRuleSubtreeStream stream_s=new RewriteRuleSubtreeStream(adaptor,"rule s",s!=null?s.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 180:7: -> ^( FUN $id $p ^( RETTYPE $r) $d $s)
			{
				DebugLocation(180, 10);
				// Mini.g:180:10: ^( FUN $id $p ^( RETTYPE $r) $d $s)
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(180, 12);
				root_1 = (object)adaptor.BecomeRoot(stream_FUN.NextNode(), root_1);

				DebugLocation(180, 17);
				adaptor.AddChild(root_1, stream_id.NextNode());
				DebugLocation(180, 21);
				adaptor.AddChild(root_1, stream_p.NextTree());
				DebugLocation(180, 23);
				// Mini.g:180:23: ^( RETTYPE $r)
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(180, 25);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(RETTYPE, "RETTYPE"), root_2);

				DebugLocation(180, 34);
				adaptor.AddChild(root_2, stream_r.NextTree());

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(180, 38);
				adaptor.AddChild(root_1, stream_d.NextTree());
				DebugLocation(180, 41);
				adaptor.AddChild(root_1, stream_s.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("function", 12);
			LeaveRule("function", 12);
			LeaveRule_function();
		}
		DebugLocation(181, 3);
		} finally { DebugExitRule(GrammarFileName, "function"); }
		return retval;

	}
	// $ANTLR end "function"

	partial void EnterRule_parameters();
	partial void LeaveRule_parameters();
	// $ANTLR start "parameters"
	// Mini.g:182:1: parameters : LPAREN ( decl ( COMMA decl )* )? RPAREN -> ^( PARAMS ( decl )* ) ;
	[GrammarRule("parameters")]
	private AstParserRuleReturnScope<object, IToken> parameters()
	{
		EnterRule_parameters();
		EnterRule("parameters", 13);
		TraceIn("parameters", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LPAREN26 = default(IToken);
		IToken COMMA28 = default(IToken);
		IToken RPAREN30 = default(IToken);
		AstParserRuleReturnScope<object, IToken> decl27 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> decl29 = default(AstParserRuleReturnScope<object, IToken>);

		object LPAREN26_tree = default(object);
		object COMMA28_tree = default(object);
		object RPAREN30_tree = default(object);
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_decl=new RewriteRuleSubtreeStream(adaptor,"rule decl");
		try { DebugEnterRule(GrammarFileName, "parameters");
		DebugLocation(182, 3);
		try
		{
			// Mini.g:183:4: ( LPAREN ( decl ( COMMA decl )* )? RPAREN -> ^( PARAMS ( decl )* ) )
			DebugEnterAlt(1);
			// Mini.g:183:7: LPAREN ( decl ( COMMA decl )* )? RPAREN
			{
			DebugLocation(183, 7);
			LPAREN26=(IToken)Match(input,LPAREN,Follow._LPAREN_in_parameters1495); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN26);

			DebugLocation(183, 14);
			// Mini.g:183:14: ( decl ( COMMA decl )* )?
			int alt9=2;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			int LA9_1 = input.LA(1);

			if ((LA9_1==BOOL||LA9_1==INT||LA9_1==STRUCT))
			{
				alt9 = 1;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// Mini.g:183:15: decl ( COMMA decl )*
				{
				DebugLocation(183, 15);
				PushFollow(Follow._decl_in_parameters1498);
				decl27=decl();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_decl.Add(decl27.Tree);
				DebugLocation(183, 20);
				// Mini.g:183:20: ( COMMA decl )*
				try { DebugEnterSubRule(8);
				while (true)
				{
					int alt8=2;
					try { DebugEnterDecision(8, false);
					int LA8_1 = input.LA(1);

					if ((LA8_1==COMMA))
					{
						alt8 = 1;
					}


					} finally { DebugExitDecision(8); }
					switch ( alt8 )
					{
					case 1:
						DebugEnterAlt(1);
						// Mini.g:183:21: COMMA decl
						{
						DebugLocation(183, 21);
						COMMA28=(IToken)Match(input,COMMA,Follow._COMMA_in_parameters1501); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(COMMA28);

						DebugLocation(183, 27);
						PushFollow(Follow._decl_in_parameters1503);
						decl29=decl();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_decl.Add(decl29.Tree);

						}
						break;

					default:
						goto loop8;
					}
				}

				loop8:
					;

				} finally { DebugExitSubRule(8); }


				}
				break;

			}
			} finally { DebugExitSubRule(9); }

			DebugLocation(183, 36);
			RPAREN30=(IToken)Match(input,RPAREN,Follow._RPAREN_in_parameters1509); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN30);



			{
			// AST REWRITE
			// elements: decl
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 184:7: -> ^( PARAMS ( decl )* )
			{
				DebugLocation(184, 10);
				// Mini.g:184:10: ^( PARAMS ( decl )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(184, 12);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PARAMS, "PARAMS"), root_1);

				DebugLocation(184, 19);
				// Mini.g:184:19: ( decl )*
				while ( stream_decl.HasNext )
				{
					DebugLocation(184, 19);
					adaptor.AddChild(root_1, stream_decl.NextTree());

				}
				stream_decl.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("parameters", 13);
			LeaveRule("parameters", 13);
			LeaveRule_parameters();
		}
		DebugLocation(185, 3);
		} finally { DebugExitRule(GrammarFileName, "parameters"); }
		return retval;

	}
	// $ANTLR end "parameters"

	partial void EnterRule_return_type();
	partial void LeaveRule_return_type();
	// $ANTLR start "return_type"
	// Mini.g:186:1: return_type : ( type | VOID );
	[GrammarRule("return_type")]
	private AstParserRuleReturnScope<object, IToken> return_type()
	{
		EnterRule_return_type();
		EnterRule("return_type", 14);
		TraceIn("return_type", 14);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken VOID32 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type31 = default(AstParserRuleReturnScope<object, IToken>);

		object VOID32_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "return_type");
		DebugLocation(186, 3);
		try
		{
			// Mini.g:187:4: ( type | VOID )
			int alt10=2;
			try { DebugEnterDecision(10, false);
			int LA10_1 = input.LA(1);

			if ((LA10_1==BOOL||LA10_1==INT||LA10_1==STRUCT))
			{
				alt10 = 1;
			}
			else if ((LA10_1==VOID))
			{
				alt10 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 10, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// Mini.g:187:7: type
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(187, 7);
				PushFollow(Follow._type_in_return_type1539);
				type31=type();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, type31.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Mini.g:188:7: VOID
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(188, 7);
				VOID32=(IToken)Match(input,VOID,Follow._VOID_in_return_type1547); if (state.failed) return retval;
				if (state.backtracking == 0) {
				VOID32_tree = (object)adaptor.Create(VOID32);
				adaptor.AddChild(root_0, VOID32_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("return_type", 14);
			LeaveRule("return_type", 14);
			LeaveRule_return_type();
		}
		DebugLocation(189, 3);
		} finally { DebugExitRule(GrammarFileName, "return_type"); }
		return retval;

	}
	// $ANTLR end "return_type"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();
	// $ANTLR start "statement"
	// Mini.g:190:1: statement : ( block | ( lvalue ASSIGN )=> assignment | print | read | conditional | loop | delete | ret | ( ID LPAREN )=> invocation );
	[GrammarRule("statement")]
	private AstParserRuleReturnScope<object, IToken> statement()
	{
		EnterRule_statement();
		EnterRule("statement", 15);
		TraceIn("statement", 15);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> block33 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignment34 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> print35 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> read36 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> conditional37 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> loop38 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> delete39 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> ret40 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> invocation41 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(190, 3);
		try
		{
			// Mini.g:191:4: ( block | ( lvalue ASSIGN )=> assignment | print | read | conditional | loop | delete | ret | ( ID LPAREN )=> invocation )
			int alt11=9;
			try { DebugEnterDecision(11, false);
			switch (input.LA(1))
			{
			case LBRACE:
				{
				alt11 = 1;
				}
				break;
			case ID:
				{
				int LA11_2 = input.LA(2);

				if ((LA11_2==DOT) && (EvaluatePredicate(synpred3_Mini_fragment)))
				{
					alt11 = 2;
				}
				else if ((LA11_2==ASSIGN) && (EvaluatePredicate(synpred3_Mini_fragment)))
				{
					alt11 = 2;
				}
				else if ((LA11_2==LPAREN) && (EvaluatePredicate(synpred4_Mini_fragment)))
				{
					alt11 = 9;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 11, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case PRINT:
				{
				alt11 = 3;
				}
				break;
			case READ:
				{
				alt11 = 4;
				}
				break;
			case IF:
				{
				alt11 = 5;
				}
				break;
			case WHILE:
				{
				alt11 = 6;
				}
				break;
			case DELETE:
				{
				alt11 = 7;
				}
				break;
			case RETURN:
				{
				alt11 = 8;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 11, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// Mini.g:191:7: block
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(191, 7);
				PushFollow(Follow._block_in_statement1562);
				block33=block();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, block33.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Mini.g:192:7: ( lvalue ASSIGN )=> assignment
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(192, 26);
				PushFollow(Follow._assignment_in_statement1578);
				assignment34=assignment();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assignment34.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Mini.g:193:7: print
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(193, 7);
				PushFollow(Follow._print_in_statement1586);
				print35=print();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, print35.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Mini.g:194:7: read
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(194, 7);
				PushFollow(Follow._read_in_statement1594);
				read36=read();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, read36.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Mini.g:195:7: conditional
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(195, 7);
				PushFollow(Follow._conditional_in_statement1602);
				conditional37=conditional();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, conditional37.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Mini.g:196:7: loop
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(196, 7);
				PushFollow(Follow._loop_in_statement1610);
				loop38=loop();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, loop38.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Mini.g:197:7: delete
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(197, 7);
				PushFollow(Follow._delete_in_statement1618);
				delete39=delete();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, delete39.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// Mini.g:198:7: ret
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(198, 7);
				PushFollow(Follow._ret_in_statement1626);
				ret40=ret();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ret40.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// Mini.g:199:7: ( ID LPAREN )=> invocation
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(199, 22);
				PushFollow(Follow._invocation_in_statement1642);
				invocation41=invocation();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, invocation41.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("statement", 15);
			LeaveRule("statement", 15);
			LeaveRule_statement();
		}
		DebugLocation(200, 3);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return retval;

	}
	// $ANTLR end "statement"

	partial void EnterRule_block();
	partial void LeaveRule_block();
	// $ANTLR start "block"
	// Mini.g:201:1: block : LBRACE s= statement_list RBRACE -> ^( BLOCK $s) ;
	[GrammarRule("block")]
	private AstParserRuleReturnScope<object, IToken> block()
	{
		EnterRule_block();
		EnterRule("block", 16);
		TraceIn("block", 16);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LBRACE42 = default(IToken);
		IToken RBRACE43 = default(IToken);
		AstParserRuleReturnScope<object, IToken> s = default(AstParserRuleReturnScope<object, IToken>);

		object LBRACE42_tree = default(object);
		object RBRACE43_tree = default(object);
		RewriteRuleITokenStream stream_LBRACE=new RewriteRuleITokenStream(adaptor,"token LBRACE");
		RewriteRuleITokenStream stream_RBRACE=new RewriteRuleITokenStream(adaptor,"token RBRACE");
		RewriteRuleSubtreeStream stream_statement_list=new RewriteRuleSubtreeStream(adaptor,"rule statement_list");
		try { DebugEnterRule(GrammarFileName, "block");
		DebugLocation(201, 3);
		try
		{
			// Mini.g:202:4: ( LBRACE s= statement_list RBRACE -> ^( BLOCK $s) )
			DebugEnterAlt(1);
			// Mini.g:202:7: LBRACE s= statement_list RBRACE
			{
			DebugLocation(202, 7);
			LBRACE42=(IToken)Match(input,LBRACE,Follow._LBRACE_in_block1657); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LBRACE.Add(LBRACE42);

			DebugLocation(202, 15);
			PushFollow(Follow._statement_list_in_block1661);
			s=statement_list();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statement_list.Add(s.Tree);
			DebugLocation(202, 31);
			RBRACE43=(IToken)Match(input,RBRACE,Follow._RBRACE_in_block1663); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RBRACE.Add(RBRACE43);



			{
			// AST REWRITE
			// elements: s
			// token labels: 
			// rule labels: s, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_s=new RewriteRuleSubtreeStream(adaptor,"rule s",s!=null?s.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 203:7: -> ^( BLOCK $s)
			{
				DebugLocation(203, 10);
				// Mini.g:203:10: ^( BLOCK $s)
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(203, 12);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(BLOCK, "BLOCK"), root_1);

				DebugLocation(203, 19);
				adaptor.AddChild(root_1, stream_s.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("block", 16);
			LeaveRule("block", 16);
			LeaveRule_block();
		}
		DebugLocation(204, 3);
		} finally { DebugExitRule(GrammarFileName, "block"); }
		return retval;

	}
	// $ANTLR end "block"

	partial void EnterRule_statement_list();
	partial void LeaveRule_statement_list();
	// $ANTLR start "statement_list"
	// Mini.g:205:1: statement_list : ( statement )* -> ^( STMTS ( statement )* ) ;
	[GrammarRule("statement_list")]
	private AstParserRuleReturnScope<object, IToken> statement_list()
	{
		EnterRule_statement_list();
		EnterRule("statement_list", 17);
		TraceIn("statement_list", 17);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> statement44 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "statement_list");
		DebugLocation(205, 3);
		try
		{
			// Mini.g:206:4: ( ( statement )* -> ^( STMTS ( statement )* ) )
			DebugEnterAlt(1);
			// Mini.g:206:7: ( statement )*
			{
			DebugLocation(206, 7);
			// Mini.g:206:7: ( statement )*
			try { DebugEnterSubRule(12);
			while (true)
			{
				int alt12=2;
				try { DebugEnterDecision(12, false);
				int LA12_1 = input.LA(1);

				if ((LA12_1==DELETE||(LA12_1>=ID && LA12_1<=IF)||LA12_1==LBRACE||LA12_1==PRINT||LA12_1==READ||LA12_1==RETURN||LA12_1==WHILE))
				{
					alt12 = 1;
				}


				} finally { DebugExitDecision(12); }
				switch ( alt12 )
				{
				case 1:
					DebugEnterAlt(1);
					// Mini.g:206:8: statement
					{
					DebugLocation(206, 8);
					PushFollow(Follow._statement_in_statement_list1694);
					statement44=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(statement44.Tree);

					}
					break;

				default:
					goto loop12;
				}
			}

			loop12:
				;

			} finally { DebugExitSubRule(12); }



			{
			// AST REWRITE
			// elements: statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 206:20: -> ^( STMTS ( statement )* )
			{
				DebugLocation(206, 23);
				// Mini.g:206:23: ^( STMTS ( statement )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(206, 25);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(STMTS, "STMTS"), root_1);

				DebugLocation(206, 31);
				// Mini.g:206:31: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(206, 31);
					adaptor.AddChild(root_1, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("statement_list", 17);
			LeaveRule("statement_list", 17);
			LeaveRule_statement_list();
		}
		DebugLocation(207, 3);
		} finally { DebugExitRule(GrammarFileName, "statement_list"); }
		return retval;

	}
	// $ANTLR end "statement_list"

	partial void EnterRule_assignment();
	partial void LeaveRule_assignment();
	// $ANTLR start "assignment"
	// Mini.g:208:1: assignment : l= lvalue ASSIGN e= expression SEMI -> ^( ASSIGN $e $l) ;
	[GrammarRule("assignment")]
	private AstParserRuleReturnScope<object, IToken> assignment()
	{
		EnterRule_assignment();
		EnterRule("assignment", 18);
		TraceIn("assignment", 18);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ASSIGN45 = default(IToken);
		IToken SEMI46 = default(IToken);
		AstParserRuleReturnScope<object, IToken> l = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> e = default(AstParserRuleReturnScope<object, IToken>);

		object ASSIGN45_tree = default(object);
		object SEMI46_tree = default(object);
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_lvalue=new RewriteRuleSubtreeStream(adaptor,"rule lvalue");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "assignment");
		DebugLocation(208, 3);
		try
		{
			// Mini.g:209:4: (l= lvalue ASSIGN e= expression SEMI -> ^( ASSIGN $e $l) )
			DebugEnterAlt(1);
			// Mini.g:209:7: l= lvalue ASSIGN e= expression SEMI
			{
			DebugLocation(209, 8);
			PushFollow(Follow._lvalue_in_assignment1722);
			l=lvalue();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_lvalue.Add(l.Tree);
			DebugLocation(209, 16);
			ASSIGN45=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_assignment1724); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN45);

			DebugLocation(209, 24);
			PushFollow(Follow._expression_in_assignment1728);
			e=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(e.Tree);
			DebugLocation(209, 36);
			SEMI46=(IToken)Match(input,SEMI,Follow._SEMI_in_assignment1730); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI46);



			{
			// AST REWRITE
			// elements: ASSIGN, e, l
			// token labels: 
			// rule labels: e, l, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_e=new RewriteRuleSubtreeStream(adaptor,"rule e",e!=null?e.Tree:null);
			RewriteRuleSubtreeStream stream_l=new RewriteRuleSubtreeStream(adaptor,"rule l",l!=null?l.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 210:7: -> ^( ASSIGN $e $l)
			{
				DebugLocation(210, 10);
				// Mini.g:210:10: ^( ASSIGN $e $l)
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(210, 12);
				root_1 = (object)adaptor.BecomeRoot(stream_ASSIGN.NextNode(), root_1);

				DebugLocation(210, 20);
				adaptor.AddChild(root_1, stream_e.NextTree());
				DebugLocation(210, 23);
				adaptor.AddChild(root_1, stream_l.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("assignment", 18);
			LeaveRule("assignment", 18);
			LeaveRule_assignment();
		}
		DebugLocation(211, 3);
		} finally { DebugExitRule(GrammarFileName, "assignment"); }
		return retval;

	}
	// $ANTLR end "assignment"

	partial void EnterRule_print();
	partial void LeaveRule_print();
	// $ANTLR start "print"
	// Mini.g:212:1: print : PRINT ^ expression ( ENDL )? SEMI !;
	[GrammarRule("print")]
	private AstParserRuleReturnScope<object, IToken> print()
	{
		EnterRule_print();
		EnterRule("print", 19);
		TraceIn("print", 19);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken PRINT47 = default(IToken);
		IToken ENDL49 = default(IToken);
		IToken SEMI50 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression48 = default(AstParserRuleReturnScope<object, IToken>);

		object PRINT47_tree = default(object);
		object ENDL49_tree = default(object);
		object SEMI50_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "print");
		DebugLocation(212, 3);
		try
		{
			// Mini.g:213:4: ( PRINT ^ expression ( ENDL )? SEMI !)
			DebugEnterAlt(1);
			// Mini.g:213:7: PRINT ^ expression ( ENDL )? SEMI !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(213, 12);
			PRINT47=(IToken)Match(input,PRINT,Follow._PRINT_in_print1763); if (state.failed) return retval;
			if (state.backtracking == 0) {
			PRINT47_tree = (object)adaptor.Create(PRINT47);
			root_0 = (object)adaptor.BecomeRoot(PRINT47_tree, root_0);
			}
			DebugLocation(213, 14);
			PushFollow(Follow._expression_in_print1766);
			expression48=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression48.Tree);
			DebugLocation(213, 25);
			// Mini.g:213:25: ( ENDL )?
			int alt13=2;
			try { DebugEnterSubRule(13);
			try { DebugEnterDecision(13, false);
			int LA13_1 = input.LA(1);

			if ((LA13_1==ENDL))
			{
				alt13 = 1;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// Mini.g:213:26: ENDL
				{
				DebugLocation(213, 26);
				ENDL49=(IToken)Match(input,ENDL,Follow._ENDL_in_print1769); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ENDL49_tree = (object)adaptor.Create(ENDL49);
				adaptor.AddChild(root_0, ENDL49_tree);
				}

				}
				break;

			}
			} finally { DebugExitSubRule(13); }

			DebugLocation(213, 37);
			SEMI50=(IToken)Match(input,SEMI,Follow._SEMI_in_print1773); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("print", 19);
			LeaveRule("print", 19);
			LeaveRule_print();
		}
		DebugLocation(214, 3);
		} finally { DebugExitRule(GrammarFileName, "print"); }
		return retval;

	}
	// $ANTLR end "print"

	partial void EnterRule_read();
	partial void LeaveRule_read();
	// $ANTLR start "read"
	// Mini.g:215:1: read : READ ^ lvalue SEMI !;
	[GrammarRule("read")]
	private AstParserRuleReturnScope<object, IToken> read()
	{
		EnterRule_read();
		EnterRule("read", 20);
		TraceIn("read", 20);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken READ51 = default(IToken);
		IToken SEMI53 = default(IToken);
		AstParserRuleReturnScope<object, IToken> lvalue52 = default(AstParserRuleReturnScope<object, IToken>);

		object READ51_tree = default(object);
		object SEMI53_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "read");
		DebugLocation(215, 3);
		try
		{
			// Mini.g:216:4: ( READ ^ lvalue SEMI !)
			DebugEnterAlt(1);
			// Mini.g:216:7: READ ^ lvalue SEMI !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(216, 11);
			READ51=(IToken)Match(input,READ,Follow._READ_in_read1789); if (state.failed) return retval;
			if (state.backtracking == 0) {
			READ51_tree = (object)adaptor.Create(READ51);
			root_0 = (object)adaptor.BecomeRoot(READ51_tree, root_0);
			}
			DebugLocation(216, 13);
			PushFollow(Follow._lvalue_in_read1792);
			lvalue52=lvalue();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, lvalue52.Tree);
			DebugLocation(216, 24);
			SEMI53=(IToken)Match(input,SEMI,Follow._SEMI_in_read1794); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("read", 20);
			LeaveRule("read", 20);
			LeaveRule_read();
		}
		DebugLocation(217, 3);
		} finally { DebugExitRule(GrammarFileName, "read"); }
		return retval;

	}
	// $ANTLR end "read"

	partial void EnterRule_conditional();
	partial void LeaveRule_conditional();
	// $ANTLR start "conditional"
	// Mini.g:218:1: conditional : IF ^ LPAREN ! expression RPAREN ! block ( ELSE ! block )? ;
	[GrammarRule("conditional")]
	private AstParserRuleReturnScope<object, IToken> conditional()
	{
		EnterRule_conditional();
		EnterRule("conditional", 21);
		TraceIn("conditional", 21);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken IF54 = default(IToken);
		IToken LPAREN55 = default(IToken);
		IToken RPAREN57 = default(IToken);
		IToken ELSE59 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression56 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> block58 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> block60 = default(AstParserRuleReturnScope<object, IToken>);

		object IF54_tree = default(object);
		object LPAREN55_tree = default(object);
		object RPAREN57_tree = default(object);
		object ELSE59_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "conditional");
		DebugLocation(218, 3);
		try
		{
			// Mini.g:219:4: ( IF ^ LPAREN ! expression RPAREN ! block ( ELSE ! block )? )
			DebugEnterAlt(1);
			// Mini.g:219:7: IF ^ LPAREN ! expression RPAREN ! block ( ELSE ! block )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(219, 9);
			IF54=(IToken)Match(input,IF,Follow._IF_in_conditional1810); if (state.failed) return retval;
			if (state.backtracking == 0) {
			IF54_tree = (object)adaptor.Create(IF54);
			root_0 = (object)adaptor.BecomeRoot(IF54_tree, root_0);
			}
			DebugLocation(219, 17);
			LPAREN55=(IToken)Match(input,LPAREN,Follow._LPAREN_in_conditional1813); if (state.failed) return retval;
			DebugLocation(219, 19);
			PushFollow(Follow._expression_in_conditional1816);
			expression56=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression56.Tree);
			DebugLocation(219, 36);
			RPAREN57=(IToken)Match(input,RPAREN,Follow._RPAREN_in_conditional1818); if (state.failed) return retval;
			DebugLocation(219, 38);
			PushFollow(Follow._block_in_conditional1821);
			block58=block();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, block58.Tree);
			DebugLocation(219, 44);
			// Mini.g:219:44: ( ELSE ! block )?
			int alt14=2;
			try { DebugEnterSubRule(14);
			try { DebugEnterDecision(14, false);
			int LA14_1 = input.LA(1);

			if ((LA14_1==ELSE))
			{
				alt14 = 1;
			}
			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// Mini.g:219:45: ELSE ! block
				{
				DebugLocation(219, 49);
				ELSE59=(IToken)Match(input,ELSE,Follow._ELSE_in_conditional1824); if (state.failed) return retval;
				DebugLocation(219, 51);
				PushFollow(Follow._block_in_conditional1827);
				block60=block();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, block60.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(14); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("conditional", 21);
			LeaveRule("conditional", 21);
			LeaveRule_conditional();
		}
		DebugLocation(220, 3);
		} finally { DebugExitRule(GrammarFileName, "conditional"); }
		return retval;

	}
	// $ANTLR end "conditional"

	partial void EnterRule_loop();
	partial void LeaveRule_loop();
	// $ANTLR start "loop"
	// Mini.g:221:1: loop : WHILE LPAREN e= expression RPAREN b= block -> ^( WHILE $e $b $e) ;
	[GrammarRule("loop")]
	private AstParserRuleReturnScope<object, IToken> loop()
	{
		EnterRule_loop();
		EnterRule("loop", 22);
		TraceIn("loop", 22);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken WHILE61 = default(IToken);
		IToken LPAREN62 = default(IToken);
		IToken RPAREN63 = default(IToken);
		AstParserRuleReturnScope<object, IToken> e = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> b = default(AstParserRuleReturnScope<object, IToken>);

		object WHILE61_tree = default(object);
		object LPAREN62_tree = default(object);
		object RPAREN63_tree = default(object);
		RewriteRuleITokenStream stream_WHILE=new RewriteRuleITokenStream(adaptor,"token WHILE");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_block=new RewriteRuleSubtreeStream(adaptor,"rule block");
		try { DebugEnterRule(GrammarFileName, "loop");
		DebugLocation(221, 3);
		try
		{
			// Mini.g:222:4: ( WHILE LPAREN e= expression RPAREN b= block -> ^( WHILE $e $b $e) )
			DebugEnterAlt(1);
			// Mini.g:222:7: WHILE LPAREN e= expression RPAREN b= block
			{
			DebugLocation(222, 7);
			WHILE61=(IToken)Match(input,WHILE,Follow._WHILE_in_loop1844); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WHILE.Add(WHILE61);

			DebugLocation(222, 13);
			LPAREN62=(IToken)Match(input,LPAREN,Follow._LPAREN_in_loop1846); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN62);

			DebugLocation(222, 21);
			PushFollow(Follow._expression_in_loop1850);
			e=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(e.Tree);
			DebugLocation(222, 33);
			RPAREN63=(IToken)Match(input,RPAREN,Follow._RPAREN_in_loop1852); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN63);

			DebugLocation(222, 41);
			PushFollow(Follow._block_in_loop1856);
			b=block();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_block.Add(b.Tree);


			{
			// AST REWRITE
			// elements: WHILE, e, b, e
			// token labels: 
			// rule labels: e, b, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_e=new RewriteRuleSubtreeStream(adaptor,"rule e",e!=null?e.Tree:null);
			RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"rule b",b!=null?b.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 223:7: -> ^( WHILE $e $b $e)
			{
				DebugLocation(223, 10);
				// Mini.g:223:10: ^( WHILE $e $b $e)
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(223, 12);
				root_1 = (object)adaptor.BecomeRoot(stream_WHILE.NextNode(), root_1);

				DebugLocation(223, 19);
				adaptor.AddChild(root_1, stream_e.NextTree());
				DebugLocation(223, 22);
				adaptor.AddChild(root_1, stream_b.NextTree());
				DebugLocation(223, 25);
				adaptor.AddChild(root_1, stream_e.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("loop", 22);
			LeaveRule("loop", 22);
			LeaveRule_loop();
		}
		DebugLocation(224, 3);
		} finally { DebugExitRule(GrammarFileName, "loop"); }
		return retval;

	}
	// $ANTLR end "loop"

	partial void EnterRule_delete();
	partial void LeaveRule_delete();
	// $ANTLR start "delete"
	// Mini.g:225:1: delete : DELETE ^ expression SEMI !;
	[GrammarRule("delete")]
	private AstParserRuleReturnScope<object, IToken> delete()
	{
		EnterRule_delete();
		EnterRule("delete", 23);
		TraceIn("delete", 23);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken DELETE64 = default(IToken);
		IToken SEMI66 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression65 = default(AstParserRuleReturnScope<object, IToken>);

		object DELETE64_tree = default(object);
		object SEMI66_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "delete");
		DebugLocation(225, 3);
		try
		{
			// Mini.g:226:4: ( DELETE ^ expression SEMI !)
			DebugEnterAlt(1);
			// Mini.g:226:7: DELETE ^ expression SEMI !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(226, 13);
			DELETE64=(IToken)Match(input,DELETE,Follow._DELETE_in_delete1892); if (state.failed) return retval;
			if (state.backtracking == 0) {
			DELETE64_tree = (object)adaptor.Create(DELETE64);
			root_0 = (object)adaptor.BecomeRoot(DELETE64_tree, root_0);
			}
			DebugLocation(226, 15);
			PushFollow(Follow._expression_in_delete1895);
			expression65=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression65.Tree);
			DebugLocation(226, 30);
			SEMI66=(IToken)Match(input,SEMI,Follow._SEMI_in_delete1897); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("delete", 23);
			LeaveRule("delete", 23);
			LeaveRule_delete();
		}
		DebugLocation(227, 3);
		} finally { DebugExitRule(GrammarFileName, "delete"); }
		return retval;

	}
	// $ANTLR end "delete"

	partial void EnterRule_ret();
	partial void LeaveRule_ret();
	// $ANTLR start "ret"
	// Mini.g:228:1: ret : RETURN ^ ( expression )? SEMI !;
	[GrammarRule("ret")]
	private AstParserRuleReturnScope<object, IToken> ret()
	{
		EnterRule_ret();
		EnterRule("ret", 24);
		TraceIn("ret", 24);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken RETURN67 = default(IToken);
		IToken SEMI69 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression68 = default(AstParserRuleReturnScope<object, IToken>);

		object RETURN67_tree = default(object);
		object SEMI69_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "ret");
		DebugLocation(228, 3);
		try
		{
			// Mini.g:229:4: ( RETURN ^ ( expression )? SEMI !)
			DebugEnterAlt(1);
			// Mini.g:229:7: RETURN ^ ( expression )? SEMI !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(229, 13);
			RETURN67=(IToken)Match(input,RETURN,Follow._RETURN_in_ret1913); if (state.failed) return retval;
			if (state.backtracking == 0) {
			RETURN67_tree = (object)adaptor.Create(RETURN67);
			root_0 = (object)adaptor.BecomeRoot(RETURN67_tree, root_0);
			}
			DebugLocation(229, 15);
			// Mini.g:229:15: ( expression )?
			int alt15=2;
			try { DebugEnterSubRule(15);
			try { DebugEnterDecision(15, false);
			int LA15_1 = input.LA(1);

			if ((LA15_1==FALSE||LA15_1==ID||LA15_1==INTEGER||LA15_1==LPAREN||LA15_1==MINUS||(LA15_1>=NEW && LA15_1<=NULL)||LA15_1==TRUE))
			{
				alt15 = 1;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// Mini.g:229:16: expression
				{
				DebugLocation(229, 16);
				PushFollow(Follow._expression_in_ret1917);
				expression68=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expression68.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(15); }

			DebugLocation(229, 33);
			SEMI69=(IToken)Match(input,SEMI,Follow._SEMI_in_ret1921); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("ret", 24);
			LeaveRule("ret", 24);
			LeaveRule_ret();
		}
		DebugLocation(230, 3);
		} finally { DebugExitRule(GrammarFileName, "ret"); }
		return retval;

	}
	// $ANTLR end "ret"

	partial void EnterRule_invocation();
	partial void LeaveRule_invocation();
	// $ANTLR start "invocation"
	// Mini.g:231:1: invocation : id= ID a= arguments SEMI -> ^( INVOKE $id $a) ;
	[GrammarRule("invocation")]
	private AstParserRuleReturnScope<object, IToken> invocation()
	{
		EnterRule_invocation();
		EnterRule("invocation", 25);
		TraceIn("invocation", 25);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken id = default(IToken);
		IToken SEMI70 = default(IToken);
		AstParserRuleReturnScope<object, IToken> a = default(AstParserRuleReturnScope<object, IToken>);

		object id_tree = default(object);
		object SEMI70_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_arguments=new RewriteRuleSubtreeStream(adaptor,"rule arguments");
		try { DebugEnterRule(GrammarFileName, "invocation");
		DebugLocation(231, 3);
		try
		{
			// Mini.g:232:4: (id= ID a= arguments SEMI -> ^( INVOKE $id $a) )
			DebugEnterAlt(1);
			// Mini.g:232:7: id= ID a= arguments SEMI
			{
			DebugLocation(232, 9);
			id=(IToken)Match(input,ID,Follow._ID_in_invocation1939); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(id);

			DebugLocation(232, 14);
			PushFollow(Follow._arguments_in_invocation1943);
			a=arguments();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_arguments.Add(a.Tree);
			DebugLocation(232, 25);
			SEMI70=(IToken)Match(input,SEMI,Follow._SEMI_in_invocation1945); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI70);



			{
			// AST REWRITE
			// elements: id, a
			// token labels: id
			// rule labels: a, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_id=new RewriteRuleITokenStream(adaptor,"token id",id);
			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 233:7: -> ^( INVOKE $id $a)
			{
				DebugLocation(233, 10);
				// Mini.g:233:10: ^( INVOKE $id $a)
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(233, 12);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INVOKE, "INVOKE"), root_1);

				DebugLocation(233, 20);
				adaptor.AddChild(root_1, stream_id.NextNode());
				DebugLocation(233, 24);
				adaptor.AddChild(root_1, stream_a.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("invocation", 25);
			LeaveRule("invocation", 25);
			LeaveRule_invocation();
		}
		DebugLocation(234, 3);
		} finally { DebugExitRule(GrammarFileName, "invocation"); }
		return retval;

	}
	// $ANTLR end "invocation"

	partial void EnterRule_lvalue();
	partial void LeaveRule_lvalue();
	// $ANTLR start "lvalue"
	// Mini.g:235:1: lvalue : ID ( DOT ^ ID )* ;
	[GrammarRule("lvalue")]
	private AstParserRuleReturnScope<object, IToken> lvalue()
	{
		EnterRule_lvalue();
		EnterRule("lvalue", 26);
		TraceIn("lvalue", 26);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID71 = default(IToken);
		IToken DOT72 = default(IToken);
		IToken ID73 = default(IToken);

		object ID71_tree = default(object);
		object DOT72_tree = default(object);
		object ID73_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "lvalue");
		DebugLocation(235, 3);
		try
		{
			// Mini.g:236:4: ( ID ( DOT ^ ID )* )
			DebugEnterAlt(1);
			// Mini.g:236:7: ID ( DOT ^ ID )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(236, 7);
			ID71=(IToken)Match(input,ID,Follow._ID_in_lvalue1978); if (state.failed) return retval;
			if (state.backtracking == 0) {
			ID71_tree = (object)adaptor.Create(ID71);
			adaptor.AddChild(root_0, ID71_tree);
			}
			DebugLocation(236, 10);
			// Mini.g:236:10: ( DOT ^ ID )*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_1 = input.LA(1);

				if ((LA16_1==DOT))
				{
					alt16 = 1;
				}


				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// Mini.g:236:11: DOT ^ ID
					{
					DebugLocation(236, 14);
					DOT72=(IToken)Match(input,DOT,Follow._DOT_in_lvalue1981); if (state.failed) return retval;
					if (state.backtracking == 0) {
					DOT72_tree = (object)adaptor.Create(DOT72);
					root_0 = (object)adaptor.BecomeRoot(DOT72_tree, root_0);
					}
					DebugLocation(236, 16);
					ID73=(IToken)Match(input,ID,Follow._ID_in_lvalue1984); if (state.failed) return retval;
					if (state.backtracking == 0) {
					ID73_tree = (object)adaptor.Create(ID73);
					adaptor.AddChild(root_0, ID73_tree);
					}

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("lvalue", 26);
			LeaveRule("lvalue", 26);
			LeaveRule_lvalue();
		}
		DebugLocation(237, 3);
		} finally { DebugExitRule(GrammarFileName, "lvalue"); }
		return retval;

	}
	// $ANTLR end "lvalue"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();
	// $ANTLR start "expression"
	// Mini.g:238:1: expression : boolterm ( ( AND ^| OR ^) boolterm )* ;
	[GrammarRule("expression")]
	private AstParserRuleReturnScope<object, IToken> expression()
	{
		EnterRule_expression();
		EnterRule("expression", 27);
		TraceIn("expression", 27);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken AND75 = default(IToken);
		IToken OR76 = default(IToken);
		AstParserRuleReturnScope<object, IToken> boolterm74 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> boolterm77 = default(AstParserRuleReturnScope<object, IToken>);

		object AND75_tree = default(object);
		object OR76_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(238, 3);
		try
		{
			// Mini.g:239:4: ( boolterm ( ( AND ^| OR ^) boolterm )* )
			DebugEnterAlt(1);
			// Mini.g:239:7: boolterm ( ( AND ^| OR ^) boolterm )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(239, 7);
			PushFollow(Follow._boolterm_in_expression2001);
			boolterm74=boolterm();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, boolterm74.Tree);
			DebugLocation(239, 16);
			// Mini.g:239:16: ( ( AND ^| OR ^) boolterm )*
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=2;
				try { DebugEnterDecision(18, false);
				int LA18_1 = input.LA(1);

				if ((LA18_1==AND||LA18_1==OR))
				{
					alt18 = 1;
				}


				} finally { DebugExitDecision(18); }
				switch ( alt18 )
				{
				case 1:
					DebugEnterAlt(1);
					// Mini.g:239:17: ( AND ^| OR ^) boolterm
					{
					DebugLocation(239, 17);
					// Mini.g:239:17: ( AND ^| OR ^)
					int alt17=2;
					try { DebugEnterSubRule(17);
					try { DebugEnterDecision(17, false);
					int LA17_1 = input.LA(1);

					if ((LA17_1==AND))
					{
						alt17 = 1;
					}
					else if ((LA17_1==OR))
					{
						alt17 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 17, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(17); }
					switch (alt17)
					{
					case 1:
						DebugEnterAlt(1);
						// Mini.g:239:18: AND ^
						{
						DebugLocation(239, 21);
						AND75=(IToken)Match(input,AND,Follow._AND_in_expression2005); if (state.failed) return retval;
						if (state.backtracking == 0) {
						AND75_tree = (object)adaptor.Create(AND75);
						root_0 = (object)adaptor.BecomeRoot(AND75_tree, root_0);
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Mini.g:239:25: OR ^
						{
						DebugLocation(239, 27);
						OR76=(IToken)Match(input,OR,Follow._OR_in_expression2010); if (state.failed) return retval;
						if (state.backtracking == 0) {
						OR76_tree = (object)adaptor.Create(OR76);
						root_0 = (object)adaptor.BecomeRoot(OR76_tree, root_0);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(17); }

					DebugLocation(239, 30);
					PushFollow(Follow._boolterm_in_expression2014);
					boolterm77=boolterm();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, boolterm77.Tree);

					}
					break;

				default:
					goto loop18;
				}
			}

			loop18:
				;

			} finally { DebugExitSubRule(18); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("expression", 27);
			LeaveRule("expression", 27);
			LeaveRule_expression();
		}
		DebugLocation(240, 3);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return retval;

	}
	// $ANTLR end "expression"

	partial void EnterRule_boolterm();
	partial void LeaveRule_boolterm();
	// $ANTLR start "boolterm"
	// Mini.g:241:1: boolterm : simple ( ( EQ ^| LT ^| GT ^| NE ^| LE ^| GE ^) simple )? ;
	[GrammarRule("boolterm")]
	private AstParserRuleReturnScope<object, IToken> boolterm()
	{
		EnterRule_boolterm();
		EnterRule("boolterm", 28);
		TraceIn("boolterm", 28);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EQ79 = default(IToken);
		IToken LT80 = default(IToken);
		IToken GT81 = default(IToken);
		IToken NE82 = default(IToken);
		IToken LE83 = default(IToken);
		IToken GE84 = default(IToken);
		AstParserRuleReturnScope<object, IToken> simple78 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> simple85 = default(AstParserRuleReturnScope<object, IToken>);

		object EQ79_tree = default(object);
		object LT80_tree = default(object);
		object GT81_tree = default(object);
		object NE82_tree = default(object);
		object LE83_tree = default(object);
		object GE84_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "boolterm");
		DebugLocation(241, 3);
		try
		{
			// Mini.g:242:4: ( simple ( ( EQ ^| LT ^| GT ^| NE ^| LE ^| GE ^) simple )? )
			DebugEnterAlt(1);
			// Mini.g:242:7: simple ( ( EQ ^| LT ^| GT ^| NE ^| LE ^| GE ^) simple )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(242, 7);
			PushFollow(Follow._simple_in_boolterm2031);
			simple78=simple();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, simple78.Tree);
			DebugLocation(242, 14);
			// Mini.g:242:14: ( ( EQ ^| LT ^| GT ^| NE ^| LE ^| GE ^) simple )?
			int alt20=2;
			try { DebugEnterSubRule(20);
			try { DebugEnterDecision(20, false);
			int LA20_1 = input.LA(1);

			if ((LA20_1==EQ||(LA20_1>=GE && LA20_1<=GT)||LA20_1==LE||LA20_1==LT||LA20_1==NE))
			{
				alt20 = 1;
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// Mini.g:242:15: ( EQ ^| LT ^| GT ^| NE ^| LE ^| GE ^) simple
				{
				DebugLocation(242, 15);
				// Mini.g:242:15: ( EQ ^| LT ^| GT ^| NE ^| LE ^| GE ^)
				int alt19=6;
				try { DebugEnterSubRule(19);
				try { DebugEnterDecision(19, false);
				switch (input.LA(1))
				{
				case EQ:
					{
					alt19 = 1;
					}
					break;
				case LT:
					{
					alt19 = 2;
					}
					break;
				case GT:
					{
					alt19 = 3;
					}
					break;
				case NE:
					{
					alt19 = 4;
					}
					break;
				case LE:
					{
					alt19 = 5;
					}
					break;
				case GE:
					{
					alt19 = 6;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 19, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(19); }
				switch (alt19)
				{
				case 1:
					DebugEnterAlt(1);
					// Mini.g:242:16: EQ ^
					{
					DebugLocation(242, 18);
					EQ79=(IToken)Match(input,EQ,Follow._EQ_in_boolterm2035); if (state.failed) return retval;
					if (state.backtracking == 0) {
					EQ79_tree = (object)adaptor.Create(EQ79);
					root_0 = (object)adaptor.BecomeRoot(EQ79_tree, root_0);
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Mini.g:242:22: LT ^
					{
					DebugLocation(242, 24);
					LT80=(IToken)Match(input,LT,Follow._LT_in_boolterm2040); if (state.failed) return retval;
					if (state.backtracking == 0) {
					LT80_tree = (object)adaptor.Create(LT80);
					root_0 = (object)adaptor.BecomeRoot(LT80_tree, root_0);
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Mini.g:242:28: GT ^
					{
					DebugLocation(242, 30);
					GT81=(IToken)Match(input,GT,Follow._GT_in_boolterm2045); if (state.failed) return retval;
					if (state.backtracking == 0) {
					GT81_tree = (object)adaptor.Create(GT81);
					root_0 = (object)adaptor.BecomeRoot(GT81_tree, root_0);
					}

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// Mini.g:242:34: NE ^
					{
					DebugLocation(242, 36);
					NE82=(IToken)Match(input,NE,Follow._NE_in_boolterm2050); if (state.failed) return retval;
					if (state.backtracking == 0) {
					NE82_tree = (object)adaptor.Create(NE82);
					root_0 = (object)adaptor.BecomeRoot(NE82_tree, root_0);
					}

					}
					break;
				case 5:
					DebugEnterAlt(5);
					// Mini.g:242:40: LE ^
					{
					DebugLocation(242, 42);
					LE83=(IToken)Match(input,LE,Follow._LE_in_boolterm2055); if (state.failed) return retval;
					if (state.backtracking == 0) {
					LE83_tree = (object)adaptor.Create(LE83);
					root_0 = (object)adaptor.BecomeRoot(LE83_tree, root_0);
					}

					}
					break;
				case 6:
					DebugEnterAlt(6);
					// Mini.g:242:46: GE ^
					{
					DebugLocation(242, 48);
					GE84=(IToken)Match(input,GE,Follow._GE_in_boolterm2060); if (state.failed) return retval;
					if (state.backtracking == 0) {
					GE84_tree = (object)adaptor.Create(GE84);
					root_0 = (object)adaptor.BecomeRoot(GE84_tree, root_0);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(19); }

				DebugLocation(242, 51);
				PushFollow(Follow._simple_in_boolterm2064);
				simple85=simple();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, simple85.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(20); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("boolterm", 28);
			LeaveRule("boolterm", 28);
			LeaveRule_boolterm();
		}
		DebugLocation(243, 3);
		} finally { DebugExitRule(GrammarFileName, "boolterm"); }
		return retval;

	}
	// $ANTLR end "boolterm"

	partial void EnterRule_simple();
	partial void LeaveRule_simple();
	// $ANTLR start "simple"
	// Mini.g:244:1: simple : term ( ( PLUS ^| MINUS ^) term )* ;
	[GrammarRule("simple")]
	private AstParserRuleReturnScope<object, IToken> simple()
	{
		EnterRule_simple();
		EnterRule("simple", 29);
		TraceIn("simple", 29);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken PLUS87 = default(IToken);
		IToken MINUS88 = default(IToken);
		AstParserRuleReturnScope<object, IToken> term86 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> term89 = default(AstParserRuleReturnScope<object, IToken>);

		object PLUS87_tree = default(object);
		object MINUS88_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "simple");
		DebugLocation(244, 3);
		try
		{
			// Mini.g:245:4: ( term ( ( PLUS ^| MINUS ^) term )* )
			DebugEnterAlt(1);
			// Mini.g:245:7: term ( ( PLUS ^| MINUS ^) term )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(245, 7);
			PushFollow(Follow._term_in_simple2081);
			term86=term();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, term86.Tree);
			DebugLocation(245, 12);
			// Mini.g:245:12: ( ( PLUS ^| MINUS ^) term )*
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=2;
				try { DebugEnterDecision(22, false);
				int LA22_1 = input.LA(1);

				if ((LA22_1==MINUS||LA22_1==PLUS))
				{
					alt22 = 1;
				}


				} finally { DebugExitDecision(22); }
				switch ( alt22 )
				{
				case 1:
					DebugEnterAlt(1);
					// Mini.g:245:13: ( PLUS ^| MINUS ^) term
					{
					DebugLocation(245, 13);
					// Mini.g:245:13: ( PLUS ^| MINUS ^)
					int alt21=2;
					try { DebugEnterSubRule(21);
					try { DebugEnterDecision(21, false);
					int LA21_1 = input.LA(1);

					if ((LA21_1==PLUS))
					{
						alt21 = 1;
					}
					else if ((LA21_1==MINUS))
					{
						alt21 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 21, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(21); }
					switch (alt21)
					{
					case 1:
						DebugEnterAlt(1);
						// Mini.g:245:14: PLUS ^
						{
						DebugLocation(245, 18);
						PLUS87=(IToken)Match(input,PLUS,Follow._PLUS_in_simple2085); if (state.failed) return retval;
						if (state.backtracking == 0) {
						PLUS87_tree = (object)adaptor.Create(PLUS87);
						root_0 = (object)adaptor.BecomeRoot(PLUS87_tree, root_0);
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Mini.g:245:22: MINUS ^
						{
						DebugLocation(245, 27);
						MINUS88=(IToken)Match(input,MINUS,Follow._MINUS_in_simple2090); if (state.failed) return retval;
						if (state.backtracking == 0) {
						MINUS88_tree = (object)adaptor.Create(MINUS88);
						root_0 = (object)adaptor.BecomeRoot(MINUS88_tree, root_0);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(21); }

					DebugLocation(245, 30);
					PushFollow(Follow._term_in_simple2094);
					term89=term();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, term89.Tree);

					}
					break;

				default:
					goto loop22;
				}
			}

			loop22:
				;

			} finally { DebugExitSubRule(22); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("simple", 29);
			LeaveRule("simple", 29);
			LeaveRule_simple();
		}
		DebugLocation(246, 3);
		} finally { DebugExitRule(GrammarFileName, "simple"); }
		return retval;

	}
	// $ANTLR end "simple"

	partial void EnterRule_term();
	partial void LeaveRule_term();
	// $ANTLR start "term"
	// Mini.g:247:1: term : unary ( ( TIMES ^| DIVIDE ^) unary )* ;
	[GrammarRule("term")]
	private AstParserRuleReturnScope<object, IToken> term()
	{
		EnterRule_term();
		EnterRule("term", 30);
		TraceIn("term", 30);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken TIMES91 = default(IToken);
		IToken DIVIDE92 = default(IToken);
		AstParserRuleReturnScope<object, IToken> unary90 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> unary93 = default(AstParserRuleReturnScope<object, IToken>);

		object TIMES91_tree = default(object);
		object DIVIDE92_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "term");
		DebugLocation(247, 3);
		try
		{
			// Mini.g:248:4: ( unary ( ( TIMES ^| DIVIDE ^) unary )* )
			DebugEnterAlt(1);
			// Mini.g:248:7: unary ( ( TIMES ^| DIVIDE ^) unary )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(248, 7);
			PushFollow(Follow._unary_in_term2111);
			unary90=unary();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, unary90.Tree);
			DebugLocation(248, 13);
			// Mini.g:248:13: ( ( TIMES ^| DIVIDE ^) unary )*
			try { DebugEnterSubRule(24);
			while (true)
			{
				int alt24=2;
				try { DebugEnterDecision(24, false);
				int LA24_1 = input.LA(1);

				if ((LA24_1==DIVIDE||LA24_1==TIMES))
				{
					alt24 = 1;
				}


				} finally { DebugExitDecision(24); }
				switch ( alt24 )
				{
				case 1:
					DebugEnterAlt(1);
					// Mini.g:248:14: ( TIMES ^| DIVIDE ^) unary
					{
					DebugLocation(248, 14);
					// Mini.g:248:14: ( TIMES ^| DIVIDE ^)
					int alt23=2;
					try { DebugEnterSubRule(23);
					try { DebugEnterDecision(23, false);
					int LA23_1 = input.LA(1);

					if ((LA23_1==TIMES))
					{
						alt23 = 1;
					}
					else if ((LA23_1==DIVIDE))
					{
						alt23 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 23, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(23); }
					switch (alt23)
					{
					case 1:
						DebugEnterAlt(1);
						// Mini.g:248:15: TIMES ^
						{
						DebugLocation(248, 20);
						TIMES91=(IToken)Match(input,TIMES,Follow._TIMES_in_term2115); if (state.failed) return retval;
						if (state.backtracking == 0) {
						TIMES91_tree = (object)adaptor.Create(TIMES91);
						root_0 = (object)adaptor.BecomeRoot(TIMES91_tree, root_0);
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Mini.g:248:24: DIVIDE ^
						{
						DebugLocation(248, 30);
						DIVIDE92=(IToken)Match(input,DIVIDE,Follow._DIVIDE_in_term2120); if (state.failed) return retval;
						if (state.backtracking == 0) {
						DIVIDE92_tree = (object)adaptor.Create(DIVIDE92);
						root_0 = (object)adaptor.BecomeRoot(DIVIDE92_tree, root_0);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(23); }

					DebugLocation(248, 33);
					PushFollow(Follow._unary_in_term2124);
					unary93=unary();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, unary93.Tree);

					}
					break;

				default:
					goto loop24;
				}
			}

			loop24:
				;

			} finally { DebugExitSubRule(24); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("term", 30);
			LeaveRule("term", 30);
			LeaveRule_term();
		}
		DebugLocation(249, 3);
		} finally { DebugExitRule(GrammarFileName, "term"); }
		return retval;

	}
	// $ANTLR end "term"

	partial void EnterRule_unary();
	partial void LeaveRule_unary();
	// $ANTLR start "unary"
	// Mini.g:250:1: unary : ( NOT ! odd_not | MINUS ! odd_neg | selector );
	[GrammarRule("unary")]
	private AstParserRuleReturnScope<object, IToken> unary()
	{
		EnterRule_unary();
		EnterRule("unary", 31);
		TraceIn("unary", 31);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken NOT94 = default(IToken);
		IToken MINUS96 = default(IToken);
		AstParserRuleReturnScope<object, IToken> odd_not95 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> odd_neg97 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> selector98 = default(AstParserRuleReturnScope<object, IToken>);

		object NOT94_tree = default(object);
		object MINUS96_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "unary");
		DebugLocation(250, 3);
		try
		{
			// Mini.g:251:4: ( NOT ! odd_not | MINUS ! odd_neg | selector )
			int alt25=3;
			try { DebugEnterDecision(25, false);
			switch (input.LA(1))
			{
			case NOT:
				{
				alt25 = 1;
				}
				break;
			case MINUS:
				{
				alt25 = 2;
				}
				break;
			case FALSE:
			case ID:
			case INTEGER:
			case LPAREN:
			case NEW:
			case NULL:
			case TRUE:
				{
				alt25 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 25, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(25); }
			switch (alt25)
			{
			case 1:
				DebugEnterAlt(1);
				// Mini.g:251:7: NOT ! odd_not
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(251, 10);
				NOT94=(IToken)Match(input,NOT,Follow._NOT_in_unary2141); if (state.failed) return retval;
				DebugLocation(251, 12);
				PushFollow(Follow._odd_not_in_unary2144);
				odd_not95=odd_not();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, odd_not95.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Mini.g:252:7: MINUS ! odd_neg
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(252, 12);
				MINUS96=(IToken)Match(input,MINUS,Follow._MINUS_in_unary2152); if (state.failed) return retval;
				DebugLocation(252, 14);
				PushFollow(Follow._odd_neg_in_unary2155);
				odd_neg97=odd_neg();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, odd_neg97.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Mini.g:253:7: selector
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(253, 7);
				PushFollow(Follow._selector_in_unary2163);
				selector98=selector();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, selector98.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("unary", 31);
			LeaveRule("unary", 31);
			LeaveRule_unary();
		}
		DebugLocation(254, 3);
		} finally { DebugExitRule(GrammarFileName, "unary"); }
		return retval;

	}
	// $ANTLR end "unary"

	partial void EnterRule_odd_not();
	partial void LeaveRule_odd_not();
	// $ANTLR start "odd_not"
	// Mini.g:255:1: odd_not : ( NOT ! even_not |s= selector -> ^( NOT $s) );
	[GrammarRule("odd_not")]
	private AstParserRuleReturnScope<object, IToken> odd_not()
	{
		EnterRule_odd_not();
		EnterRule("odd_not", 32);
		TraceIn("odd_not", 32);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken NOT99 = default(IToken);
		AstParserRuleReturnScope<object, IToken> s = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> even_not100 = default(AstParserRuleReturnScope<object, IToken>);

		object NOT99_tree = default(object);
		RewriteRuleSubtreeStream stream_selector=new RewriteRuleSubtreeStream(adaptor,"rule selector");
		try { DebugEnterRule(GrammarFileName, "odd_not");
		DebugLocation(255, 3);
		try
		{
			// Mini.g:256:4: ( NOT ! even_not |s= selector -> ^( NOT $s) )
			int alt26=2;
			try { DebugEnterDecision(26, false);
			int LA26_1 = input.LA(1);

			if ((LA26_1==NOT))
			{
				alt26 = 1;
			}
			else if ((LA26_1==FALSE||LA26_1==ID||LA26_1==INTEGER||LA26_1==LPAREN||LA26_1==NEW||LA26_1==NULL||LA26_1==TRUE))
			{
				alt26 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 26, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// Mini.g:256:7: NOT ! even_not
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(256, 10);
				NOT99=(IToken)Match(input,NOT,Follow._NOT_in_odd_not2178); if (state.failed) return retval;
				DebugLocation(256, 12);
				PushFollow(Follow._even_not_in_odd_not2181);
				even_not100=even_not();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, even_not100.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Mini.g:257:7: s= selector
				{
				DebugLocation(257, 8);
				PushFollow(Follow._selector_in_odd_not2191);
				s=selector();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_selector.Add(s.Tree);


				{
				// AST REWRITE
				// elements: s
				// token labels: 
				// rule labels: s, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_s=new RewriteRuleSubtreeStream(adaptor,"rule s",s!=null?s.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 258:7: -> ^( NOT $s)
				{
					DebugLocation(258, 10);
					// Mini.g:258:10: ^( NOT $s)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(258, 12);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(NOT, "NOT"), root_1);

					DebugLocation(258, 17);
					adaptor.AddChild(root_1, stream_s.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("odd_not", 32);
			LeaveRule("odd_not", 32);
			LeaveRule_odd_not();
		}
		DebugLocation(259, 3);
		} finally { DebugExitRule(GrammarFileName, "odd_not"); }
		return retval;

	}
	// $ANTLR end "odd_not"

	partial void EnterRule_even_not();
	partial void LeaveRule_even_not();
	// $ANTLR start "even_not"
	// Mini.g:260:1: even_not : ( NOT ! odd_not | selector );
	[GrammarRule("even_not")]
	private AstParserRuleReturnScope<object, IToken> even_not()
	{
		EnterRule_even_not();
		EnterRule("even_not", 33);
		TraceIn("even_not", 33);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken NOT101 = default(IToken);
		AstParserRuleReturnScope<object, IToken> odd_not102 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> selector103 = default(AstParserRuleReturnScope<object, IToken>);

		object NOT101_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "even_not");
		DebugLocation(260, 3);
		try
		{
			// Mini.g:261:4: ( NOT ! odd_not | selector )
			int alt27=2;
			try { DebugEnterDecision(27, false);
			int LA27_1 = input.LA(1);

			if ((LA27_1==NOT))
			{
				alt27 = 1;
			}
			else if ((LA27_1==FALSE||LA27_1==ID||LA27_1==INTEGER||LA27_1==LPAREN||LA27_1==NEW||LA27_1==NULL||LA27_1==TRUE))
			{
				alt27 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 27, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(27); }
			switch (alt27)
			{
			case 1:
				DebugEnterAlt(1);
				// Mini.g:261:7: NOT ! odd_not
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(261, 10);
				NOT101=(IToken)Match(input,NOT,Follow._NOT_in_even_not2221); if (state.failed) return retval;
				DebugLocation(261, 12);
				PushFollow(Follow._odd_not_in_even_not2224);
				odd_not102=odd_not();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, odd_not102.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Mini.g:262:7: selector
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(262, 7);
				PushFollow(Follow._selector_in_even_not2232);
				selector103=selector();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, selector103.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("even_not", 33);
			LeaveRule("even_not", 33);
			LeaveRule_even_not();
		}
		DebugLocation(263, 3);
		} finally { DebugExitRule(GrammarFileName, "even_not"); }
		return retval;

	}
	// $ANTLR end "even_not"

	partial void EnterRule_odd_neg();
	partial void LeaveRule_odd_neg();
	// $ANTLR start "odd_neg"
	// Mini.g:264:1: odd_neg : ( MINUS ! even_neg |s= selector -> ^( NEG $s) );
	[GrammarRule("odd_neg")]
	private AstParserRuleReturnScope<object, IToken> odd_neg()
	{
		EnterRule_odd_neg();
		EnterRule("odd_neg", 34);
		TraceIn("odd_neg", 34);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken MINUS104 = default(IToken);
		AstParserRuleReturnScope<object, IToken> s = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> even_neg105 = default(AstParserRuleReturnScope<object, IToken>);

		object MINUS104_tree = default(object);
		RewriteRuleSubtreeStream stream_selector=new RewriteRuleSubtreeStream(adaptor,"rule selector");
		try { DebugEnterRule(GrammarFileName, "odd_neg");
		DebugLocation(264, 3);
		try
		{
			// Mini.g:265:4: ( MINUS ! even_neg |s= selector -> ^( NEG $s) )
			int alt28=2;
			try { DebugEnterDecision(28, false);
			int LA28_1 = input.LA(1);

			if ((LA28_1==MINUS))
			{
				alt28 = 1;
			}
			else if ((LA28_1==FALSE||LA28_1==ID||LA28_1==INTEGER||LA28_1==LPAREN||LA28_1==NEW||LA28_1==NULL||LA28_1==TRUE))
			{
				alt28 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 28, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(28); }
			switch (alt28)
			{
			case 1:
				DebugEnterAlt(1);
				// Mini.g:265:7: MINUS ! even_neg
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(265, 12);
				MINUS104=(IToken)Match(input,MINUS,Follow._MINUS_in_odd_neg2247); if (state.failed) return retval;
				DebugLocation(265, 14);
				PushFollow(Follow._even_neg_in_odd_neg2250);
				even_neg105=even_neg();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, even_neg105.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Mini.g:266:7: s= selector
				{
				DebugLocation(266, 8);
				PushFollow(Follow._selector_in_odd_neg2260);
				s=selector();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_selector.Add(s.Tree);


				{
				// AST REWRITE
				// elements: s
				// token labels: 
				// rule labels: s, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_s=new RewriteRuleSubtreeStream(adaptor,"rule s",s!=null?s.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 267:7: -> ^( NEG $s)
				{
					DebugLocation(267, 10);
					// Mini.g:267:10: ^( NEG $s)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(267, 12);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(NEG, "NEG"), root_1);

					DebugLocation(267, 17);
					adaptor.AddChild(root_1, stream_s.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("odd_neg", 34);
			LeaveRule("odd_neg", 34);
			LeaveRule_odd_neg();
		}
		DebugLocation(268, 3);
		} finally { DebugExitRule(GrammarFileName, "odd_neg"); }
		return retval;

	}
	// $ANTLR end "odd_neg"

	partial void EnterRule_even_neg();
	partial void LeaveRule_even_neg();
	// $ANTLR start "even_neg"
	// Mini.g:269:1: even_neg : ( MINUS ! odd_neg | selector );
	[GrammarRule("even_neg")]
	private AstParserRuleReturnScope<object, IToken> even_neg()
	{
		EnterRule_even_neg();
		EnterRule("even_neg", 35);
		TraceIn("even_neg", 35);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken MINUS106 = default(IToken);
		AstParserRuleReturnScope<object, IToken> odd_neg107 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> selector108 = default(AstParserRuleReturnScope<object, IToken>);

		object MINUS106_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "even_neg");
		DebugLocation(269, 3);
		try
		{
			// Mini.g:270:4: ( MINUS ! odd_neg | selector )
			int alt29=2;
			try { DebugEnterDecision(29, false);
			int LA29_1 = input.LA(1);

			if ((LA29_1==MINUS))
			{
				alt29 = 1;
			}
			else if ((LA29_1==FALSE||LA29_1==ID||LA29_1==INTEGER||LA29_1==LPAREN||LA29_1==NEW||LA29_1==NULL||LA29_1==TRUE))
			{
				alt29 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 29, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(29); }
			switch (alt29)
			{
			case 1:
				DebugEnterAlt(1);
				// Mini.g:270:7: MINUS ! odd_neg
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(270, 12);
				MINUS106=(IToken)Match(input,MINUS,Follow._MINUS_in_even_neg2290); if (state.failed) return retval;
				DebugLocation(270, 14);
				PushFollow(Follow._odd_neg_in_even_neg2293);
				odd_neg107=odd_neg();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, odd_neg107.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Mini.g:271:7: selector
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(271, 7);
				PushFollow(Follow._selector_in_even_neg2301);
				selector108=selector();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, selector108.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("even_neg", 35);
			LeaveRule("even_neg", 35);
			LeaveRule_even_neg();
		}
		DebugLocation(272, 3);
		} finally { DebugExitRule(GrammarFileName, "even_neg"); }
		return retval;

	}
	// $ANTLR end "even_neg"

	partial void EnterRule_selector();
	partial void LeaveRule_selector();
	// $ANTLR start "selector"
	// Mini.g:273:1: selector : factor ( DOT ^ ID )* ;
	[GrammarRule("selector")]
	private AstParserRuleReturnScope<object, IToken> selector()
	{
		EnterRule_selector();
		EnterRule("selector", 36);
		TraceIn("selector", 36);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken DOT110 = default(IToken);
		IToken ID111 = default(IToken);
		AstParserRuleReturnScope<object, IToken> factor109 = default(AstParserRuleReturnScope<object, IToken>);

		object DOT110_tree = default(object);
		object ID111_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "selector");
		DebugLocation(273, 3);
		try
		{
			// Mini.g:274:4: ( factor ( DOT ^ ID )* )
			DebugEnterAlt(1);
			// Mini.g:274:7: factor ( DOT ^ ID )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(274, 7);
			PushFollow(Follow._factor_in_selector2316);
			factor109=factor();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, factor109.Tree);
			DebugLocation(274, 14);
			// Mini.g:274:14: ( DOT ^ ID )*
			try { DebugEnterSubRule(30);
			while (true)
			{
				int alt30=2;
				try { DebugEnterDecision(30, false);
				int LA30_1 = input.LA(1);

				if ((LA30_1==DOT))
				{
					alt30 = 1;
				}


				} finally { DebugExitDecision(30); }
				switch ( alt30 )
				{
				case 1:
					DebugEnterAlt(1);
					// Mini.g:274:15: DOT ^ ID
					{
					DebugLocation(274, 18);
					DOT110=(IToken)Match(input,DOT,Follow._DOT_in_selector2319); if (state.failed) return retval;
					if (state.backtracking == 0) {
					DOT110_tree = (object)adaptor.Create(DOT110);
					root_0 = (object)adaptor.BecomeRoot(DOT110_tree, root_0);
					}
					DebugLocation(274, 20);
					ID111=(IToken)Match(input,ID,Follow._ID_in_selector2322); if (state.failed) return retval;
					if (state.backtracking == 0) {
					ID111_tree = (object)adaptor.Create(ID111);
					adaptor.AddChild(root_0, ID111_tree);
					}

					}
					break;

				default:
					goto loop30;
				}
			}

			loop30:
				;

			} finally { DebugExitSubRule(30); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("selector", 36);
			LeaveRule("selector", 36);
			LeaveRule_selector();
		}
		DebugLocation(275, 3);
		} finally { DebugExitRule(GrammarFileName, "selector"); }
		return retval;

	}
	// $ANTLR end "selector"

	partial void EnterRule_factor();
	partial void LeaveRule_factor();
	// $ANTLR start "factor"
	// Mini.g:276:1: factor : ( LPAREN ! expression RPAREN !|id= ID a= arguments -> ^( INVOKE $id $a) | ID | INTEGER | TRUE | FALSE | NEW ^ ID | NULL );
	[GrammarRule("factor")]
	private AstParserRuleReturnScope<object, IToken> factor()
	{
		EnterRule_factor();
		EnterRule("factor", 37);
		TraceIn("factor", 37);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken id = default(IToken);
		IToken LPAREN112 = default(IToken);
		IToken RPAREN114 = default(IToken);
		IToken ID115 = default(IToken);
		IToken INTEGER116 = default(IToken);
		IToken TRUE117 = default(IToken);
		IToken FALSE118 = default(IToken);
		IToken NEW119 = default(IToken);
		IToken ID120 = default(IToken);
		IToken NULL121 = default(IToken);
		AstParserRuleReturnScope<object, IToken> a = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression113 = default(AstParserRuleReturnScope<object, IToken>);

		object id_tree = default(object);
		object LPAREN112_tree = default(object);
		object RPAREN114_tree = default(object);
		object ID115_tree = default(object);
		object INTEGER116_tree = default(object);
		object TRUE117_tree = default(object);
		object FALSE118_tree = default(object);
		object NEW119_tree = default(object);
		object ID120_tree = default(object);
		object NULL121_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_arguments=new RewriteRuleSubtreeStream(adaptor,"rule arguments");
		try { DebugEnterRule(GrammarFileName, "factor");
		DebugLocation(276, 3);
		try
		{
			// Mini.g:277:4: ( LPAREN ! expression RPAREN !|id= ID a= arguments -> ^( INVOKE $id $a) | ID | INTEGER | TRUE | FALSE | NEW ^ ID | NULL )
			int alt31=8;
			try { DebugEnterDecision(31, false);
			switch (input.LA(1))
			{
			case LPAREN:
				{
				alt31 = 1;
				}
				break;
			case ID:
				{
				int LA31_2 = input.LA(2);

				if ((LA31_2==LPAREN))
				{
					alt31 = 2;
				}
				else if ((LA31_2==AND||LA31_2==COMMA||(LA31_2>=DIVIDE && LA31_2<=DOT)||(LA31_2>=ENDL && LA31_2<=EQ)||(LA31_2>=GE && LA31_2<=GT)||LA31_2==LE||(LA31_2>=LT && LA31_2<=NE)||LA31_2==OR||LA31_2==PLUS||(LA31_2>=RPAREN && LA31_2<=SEMI)||LA31_2==TIMES))
				{
					alt31 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 31, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case INTEGER:
				{
				alt31 = 4;
				}
				break;
			case TRUE:
				{
				alt31 = 5;
				}
				break;
			case FALSE:
				{
				alt31 = 6;
				}
				break;
			case NEW:
				{
				alt31 = 7;
				}
				break;
			case NULL:
				{
				alt31 = 8;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 31, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(31); }
			switch (alt31)
			{
			case 1:
				DebugEnterAlt(1);
				// Mini.g:277:7: LPAREN ! expression RPAREN !
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(277, 13);
				LPAREN112=(IToken)Match(input,LPAREN,Follow._LPAREN_in_factor2339); if (state.failed) return retval;
				DebugLocation(277, 15);
				PushFollow(Follow._expression_in_factor2342);
				expression113=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expression113.Tree);
				DebugLocation(277, 32);
				RPAREN114=(IToken)Match(input,RPAREN,Follow._RPAREN_in_factor2344); if (state.failed) return retval;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Mini.g:278:7: id= ID a= arguments
				{
				DebugLocation(278, 9);
				id=(IToken)Match(input,ID,Follow._ID_in_factor2355); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(id);

				DebugLocation(278, 14);
				PushFollow(Follow._arguments_in_factor2359);
				a=arguments();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_arguments.Add(a.Tree);


				{
				// AST REWRITE
				// elements: id, a
				// token labels: id
				// rule labels: a, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_id=new RewriteRuleITokenStream(adaptor,"token id",id);
				RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 279:7: -> ^( INVOKE $id $a)
				{
					DebugLocation(279, 10);
					// Mini.g:279:10: ^( INVOKE $id $a)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(279, 12);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INVOKE, "INVOKE"), root_1);

					DebugLocation(279, 20);
					adaptor.AddChild(root_1, stream_id.NextNode());
					DebugLocation(279, 24);
					adaptor.AddChild(root_1, stream_a.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Mini.g:280:7: ID
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(280, 7);
				ID115=(IToken)Match(input,ID,Follow._ID_in_factor2385); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ID115_tree = (object)adaptor.Create(ID115);
				adaptor.AddChild(root_0, ID115_tree);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Mini.g:281:7: INTEGER
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(281, 7);
				INTEGER116=(IToken)Match(input,INTEGER,Follow._INTEGER_in_factor2393); if (state.failed) return retval;
				if (state.backtracking == 0) {
				INTEGER116_tree = (object)adaptor.Create(INTEGER116);
				adaptor.AddChild(root_0, INTEGER116_tree);
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Mini.g:282:7: TRUE
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(282, 7);
				TRUE117=(IToken)Match(input,TRUE,Follow._TRUE_in_factor2401); if (state.failed) return retval;
				if (state.backtracking == 0) {
				TRUE117_tree = (object)adaptor.Create(TRUE117);
				adaptor.AddChild(root_0, TRUE117_tree);
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Mini.g:283:7: FALSE
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(283, 7);
				FALSE118=(IToken)Match(input,FALSE,Follow._FALSE_in_factor2409); if (state.failed) return retval;
				if (state.backtracking == 0) {
				FALSE118_tree = (object)adaptor.Create(FALSE118);
				adaptor.AddChild(root_0, FALSE118_tree);
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Mini.g:284:7: NEW ^ ID
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(284, 10);
				NEW119=(IToken)Match(input,NEW,Follow._NEW_in_factor2417); if (state.failed) return retval;
				if (state.backtracking == 0) {
				NEW119_tree = (object)adaptor.Create(NEW119);
				root_0 = (object)adaptor.BecomeRoot(NEW119_tree, root_0);
				}
				DebugLocation(284, 12);
				ID120=(IToken)Match(input,ID,Follow._ID_in_factor2420); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ID120_tree = (object)adaptor.Create(ID120);
				adaptor.AddChild(root_0, ID120_tree);
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// Mini.g:285:7: NULL
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(285, 7);
				NULL121=(IToken)Match(input,NULL,Follow._NULL_in_factor2428); if (state.failed) return retval;
				if (state.backtracking == 0) {
				NULL121_tree = (object)adaptor.Create(NULL121);
				adaptor.AddChild(root_0, NULL121_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("factor", 37);
			LeaveRule("factor", 37);
			LeaveRule_factor();
		}
		DebugLocation(286, 3);
		} finally { DebugExitRule(GrammarFileName, "factor"); }
		return retval;

	}
	// $ANTLR end "factor"

	partial void EnterRule_arguments();
	partial void LeaveRule_arguments();
	// $ANTLR start "arguments"
	// Mini.g:287:1: arguments : LPAREN ! arg_list RPAREN !;
	[GrammarRule("arguments")]
	private AstParserRuleReturnScope<object, IToken> arguments()
	{
		EnterRule_arguments();
		EnterRule("arguments", 38);
		TraceIn("arguments", 38);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LPAREN122 = default(IToken);
		IToken RPAREN124 = default(IToken);
		AstParserRuleReturnScope<object, IToken> arg_list123 = default(AstParserRuleReturnScope<object, IToken>);

		object LPAREN122_tree = default(object);
		object RPAREN124_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "arguments");
		DebugLocation(287, 3);
		try
		{
			// Mini.g:288:4: ( LPAREN ! arg_list RPAREN !)
			DebugEnterAlt(1);
			// Mini.g:288:7: LPAREN ! arg_list RPAREN !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(288, 13);
			LPAREN122=(IToken)Match(input,LPAREN,Follow._LPAREN_in_arguments2443); if (state.failed) return retval;
			DebugLocation(288, 15);
			PushFollow(Follow._arg_list_in_arguments2446);
			arg_list123=arg_list();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, arg_list123.Tree);
			DebugLocation(288, 30);
			RPAREN124=(IToken)Match(input,RPAREN,Follow._RPAREN_in_arguments2448); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("arguments", 38);
			LeaveRule("arguments", 38);
			LeaveRule_arguments();
		}
		DebugLocation(289, 3);
		} finally { DebugExitRule(GrammarFileName, "arguments"); }
		return retval;

	}
	// $ANTLR end "arguments"

	partial void EnterRule_arg_list();
	partial void LeaveRule_arg_list();
	// $ANTLR start "arg_list"
	// Mini.g:290:1: arg_list : ( expression ( COMMA expression )* -> ^( ARGS ( expression )+ ) | -> ARGS );
	[GrammarRule("arg_list")]
	private AstParserRuleReturnScope<object, IToken> arg_list()
	{
		EnterRule_arg_list();
		EnterRule("arg_list", 39);
		TraceIn("arg_list", 39);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA126 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression125 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression127 = default(AstParserRuleReturnScope<object, IToken>);

		object COMMA126_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "arg_list");
		DebugLocation(290, 3);
		try
		{
			// Mini.g:291:4: ( expression ( COMMA expression )* -> ^( ARGS ( expression )+ ) | -> ARGS )
			int alt33=2;
			try { DebugEnterDecision(33, false);
			int LA33_1 = input.LA(1);

			if ((LA33_1==FALSE||LA33_1==ID||LA33_1==INTEGER||LA33_1==LPAREN||LA33_1==MINUS||(LA33_1>=NEW && LA33_1<=NULL)||LA33_1==TRUE))
			{
				alt33 = 1;
			}
			else if ((LA33_1==RPAREN))
			{
				alt33 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 33, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(33); }
			switch (alt33)
			{
			case 1:
				DebugEnterAlt(1);
				// Mini.g:291:7: expression ( COMMA expression )*
				{
				DebugLocation(291, 7);
				PushFollow(Follow._expression_in_arg_list2464);
				expression125=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression125.Tree);
				DebugLocation(291, 18);
				// Mini.g:291:18: ( COMMA expression )*
				try { DebugEnterSubRule(32);
				while (true)
				{
					int alt32=2;
					try { DebugEnterDecision(32, false);
					int LA32_1 = input.LA(1);

					if ((LA32_1==COMMA))
					{
						alt32 = 1;
					}


					} finally { DebugExitDecision(32); }
					switch ( alt32 )
					{
					case 1:
						DebugEnterAlt(1);
						// Mini.g:291:19: COMMA expression
						{
						DebugLocation(291, 19);
						COMMA126=(IToken)Match(input,COMMA,Follow._COMMA_in_arg_list2467); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(COMMA126);

						DebugLocation(291, 25);
						PushFollow(Follow._expression_in_arg_list2469);
						expression127=expression();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_expression.Add(expression127.Tree);

						}
						break;

					default:
						goto loop32;
					}
				}

				loop32:
					;

				} finally { DebugExitSubRule(32); }



				{
				// AST REWRITE
				// elements: expression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 292:7: -> ^( ARGS ( expression )+ )
				{
					DebugLocation(292, 10);
					// Mini.g:292:10: ^( ARGS ( expression )+ )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(292, 12);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARGS, "ARGS"), root_1);

					DebugLocation(292, 17);
					if (!(stream_expression.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_expression.HasNext )
					{
						DebugLocation(292, 17);
						adaptor.AddChild(root_1, stream_expression.NextTree());

					}
					stream_expression.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Mini.g:294:7: 
				{

				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 294:7: -> ARGS
				{
					DebugLocation(294, 10);
					adaptor.AddChild(root_0, (object)adaptor.Create(ARGS, "ARGS"));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}

		   catch (RecognitionException re)
		   {
		      reportError(re);
		      recover(input, re);
		      _errors = true;
		   }

		finally
		{
			TraceOut("arg_list", 39);
			LeaveRule("arg_list", 39);
			LeaveRule_arg_list();
		}
		DebugLocation(295, 3);
		} finally { DebugExitRule(GrammarFileName, "arg_list"); }
		return retval;

	}
	// $ANTLR end "arg_list"

	partial void EnterRule_synpred1_Mini_fragment();
	partial void LeaveRule_synpred1_Mini_fragment();

	// $ANTLR start synpred1_Mini
	private void synpred1_Mini_fragment()
	{
		EnterRule_synpred1_Mini_fragment();
		EnterRule("synpred1_Mini_fragment", 40);
		TraceIn("synpred1_Mini_fragment", 40);
		try
		{
			// Mini.g:143:7: ( STRUCT ID LBRACE )
			DebugEnterAlt(1);
			// Mini.g:143:8: STRUCT ID LBRACE
			{
			DebugLocation(143, 8);
			Match(input,STRUCT,Follow._STRUCT_in_synpred1_Mini1104); if (state.failed) return;
			DebugLocation(143, 15);
			Match(input,ID,Follow._ID_in_synpred1_Mini1106); if (state.failed) return;
			DebugLocation(143, 18);
			Match(input,LBRACE,Follow._LBRACE_in_synpred1_Mini1108); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_Mini_fragment", 40);
			LeaveRule("synpred1_Mini_fragment", 40);
			LeaveRule_synpred1_Mini_fragment();
		}
	}
	// $ANTLR end synpred1_Mini

	partial void EnterRule_synpred2_Mini_fragment();
	partial void LeaveRule_synpred2_Mini_fragment();

	// $ANTLR start synpred2_Mini
	private void synpred2_Mini_fragment()
	{
		EnterRule_synpred2_Mini_fragment();
		EnterRule("synpred2_Mini_fragment", 41);
		TraceIn("synpred2_Mini_fragment", 41);
		try
		{
			// Mini.g:147:7: ( STRUCT ID LBRACE )
			DebugEnterAlt(1);
			// Mini.g:147:8: STRUCT ID LBRACE
			{
			DebugLocation(147, 8);
			Match(input,STRUCT,Follow._STRUCT_in_synpred2_Mini1147); if (state.failed) return;
			DebugLocation(147, 15);
			Match(input,ID,Follow._ID_in_synpred2_Mini1149); if (state.failed) return;
			DebugLocation(147, 18);
			Match(input,LBRACE,Follow._LBRACE_in_synpred2_Mini1151); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred2_Mini_fragment", 41);
			LeaveRule("synpred2_Mini_fragment", 41);
			LeaveRule_synpred2_Mini_fragment();
		}
	}
	// $ANTLR end synpred2_Mini

	partial void EnterRule_synpred3_Mini_fragment();
	partial void LeaveRule_synpred3_Mini_fragment();

	// $ANTLR start synpred3_Mini
	private void synpred3_Mini_fragment()
	{
		EnterRule_synpred3_Mini_fragment();
		EnterRule("synpred3_Mini_fragment", 42);
		TraceIn("synpred3_Mini_fragment", 42);
		try
		{
			// Mini.g:192:7: ( lvalue ASSIGN )
			DebugEnterAlt(1);
			// Mini.g:192:8: lvalue ASSIGN
			{
			DebugLocation(192, 8);
			PushFollow(Follow._lvalue_in_synpred3_Mini1571);
			lvalue();
			PopFollow();
			if (state.failed) return;
			DebugLocation(192, 15);
			Match(input,ASSIGN,Follow._ASSIGN_in_synpred3_Mini1573); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred3_Mini_fragment", 42);
			LeaveRule("synpred3_Mini_fragment", 42);
			LeaveRule_synpred3_Mini_fragment();
		}
	}
	// $ANTLR end synpred3_Mini

	partial void EnterRule_synpred4_Mini_fragment();
	partial void LeaveRule_synpred4_Mini_fragment();

	// $ANTLR start synpred4_Mini
	private void synpred4_Mini_fragment()
	{
		EnterRule_synpred4_Mini_fragment();
		EnterRule("synpred4_Mini_fragment", 43);
		TraceIn("synpred4_Mini_fragment", 43);
		try
		{
			// Mini.g:199:7: ( ID LPAREN )
			DebugEnterAlt(1);
			// Mini.g:199:8: ID LPAREN
			{
			DebugLocation(199, 8);
			Match(input,ID,Follow._ID_in_synpred4_Mini1635); if (state.failed) return;
			DebugLocation(199, 11);
			Match(input,LPAREN,Follow._LPAREN_in_synpred4_Mini1637); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred4_Mini_fragment", 43);
			LeaveRule("synpred4_Mini_fragment", 43);
			LeaveRule_synpred4_Mini_fragment();
		}
	}
	// $ANTLR end synpred4_Mini
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _types_in_program1057 = new BitSet(new ulong[]{0x10000008200100UL});
		public static readonly BitSet _declarations_in_program1061 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _functions_in_program1065 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_program1067 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _types_sub_in_types1113 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_declaration_in_types_sub1156 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _types_sub_in_types_sub1158 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRUCT_in_type_declaration1178 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _ID_in_type_declaration1181 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _LBRACE_in_type_declaration1183 = new BitSet(new ulong[]{0x10000008000100UL});
		public static readonly BitSet _nested_decl_in_type_declaration1186 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _RBRACE_in_type_declaration1188 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _SEMI_in_type_declaration1191 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _decl_in_nested_decl1208 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _SEMI_in_nested_decl1210 = new BitSet(new ulong[]{0x10000008000102UL});
		public static readonly BitSet _type_in_decl1230 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _ID_in_decl1234 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_type1271 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BOOL_in_type1279 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRUCT_in_type1287 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _ID_in_type1290 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _declaration_in_declarations1306 = new BitSet(new ulong[]{0x10000008000102UL});
		public static readonly BitSet _type_in_declaration1334 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _id_list_in_declaration1338 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _SEMI_in_declaration1340 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_id_list1377 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _COMMA_in_id_list1380 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _ID_in_id_list1383 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _function_in_functions1400 = new BitSet(new ulong[]{0x200002UL});
		public static readonly BitSet _FUN_in_function1425 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _ID_in_function1429 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _parameters_in_function1433 = new BitSet(new ulong[]{0x210000008000100UL});
		public static readonly BitSet _return_type_in_function1437 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _LBRACE_in_function1439 = new BitSet(new ulong[]{0x41168004E004100UL});
		public static readonly BitSet _declarations_in_function1443 = new BitSet(new ulong[]{0x401680046004000UL});
		public static readonly BitSet _statement_list_in_function1447 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _RBRACE_in_function1449 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_parameters1495 = new BitSet(new ulong[]{0x12000008000100UL});
		public static readonly BitSet _decl_in_parameters1498 = new BitSet(new ulong[]{0x2000000000200UL});
		public static readonly BitSet _COMMA_in_parameters1501 = new BitSet(new ulong[]{0x10000008000100UL});
		public static readonly BitSet _decl_in_parameters1503 = new BitSet(new ulong[]{0x2000000000200UL});
		public static readonly BitSet _RPAREN_in_parameters1509 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_in_return_type1539 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VOID_in_return_type1547 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _block_in_statement1562 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignment_in_statement1578 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _print_in_statement1586 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _read_in_statement1594 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _conditional_in_statement1602 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _loop_in_statement1610 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _delete_in_statement1618 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ret_in_statement1626 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _invocation_in_statement1642 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACE_in_block1657 = new BitSet(new ulong[]{0x401680046004000UL});
		public static readonly BitSet _statement_list_in_block1661 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _RBRACE_in_block1663 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_statement_list1694 = new BitSet(new ulong[]{0x401480046004002UL});
		public static readonly BitSet _lvalue_in_assignment1722 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _ASSIGN_in_assignment1724 = new BitSet(new ulong[]{0x4000E512100000UL});
		public static readonly BitSet _expression_in_assignment1728 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _SEMI_in_assignment1730 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PRINT_in_print1763 = new BitSet(new ulong[]{0x4000E512100000UL});
		public static readonly BitSet _expression_in_print1766 = new BitSet(new ulong[]{0x4000000040000UL});
		public static readonly BitSet _ENDL_in_print1769 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _SEMI_in_print1773 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _READ_in_read1789 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _lvalue_in_read1792 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _SEMI_in_read1794 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_conditional1810 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _LPAREN_in_conditional1813 = new BitSet(new ulong[]{0x4000E512100000UL});
		public static readonly BitSet _expression_in_conditional1816 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _RPAREN_in_conditional1818 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _block_in_conditional1821 = new BitSet(new ulong[]{0x20002UL});
		public static readonly BitSet _ELSE_in_conditional1824 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _block_in_conditional1827 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_loop1844 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _LPAREN_in_loop1846 = new BitSet(new ulong[]{0x4000E512100000UL});
		public static readonly BitSet _expression_in_loop1850 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _RPAREN_in_loop1852 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _block_in_loop1856 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DELETE_in_delete1892 = new BitSet(new ulong[]{0x4000E512100000UL});
		public static readonly BitSet _expression_in_delete1895 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _SEMI_in_delete1897 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RETURN_in_ret1913 = new BitSet(new ulong[]{0x4400E512100000UL});
		public static readonly BitSet _expression_in_ret1917 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _SEMI_in_ret1921 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_invocation1939 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _arguments_in_invocation1943 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _SEMI_in_invocation1945 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_lvalue1978 = new BitSet(new ulong[]{0x10002UL});
		public static readonly BitSet _DOT_in_lvalue1981 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _ID_in_lvalue1984 = new BitSet(new ulong[]{0x10002UL});
		public static readonly BitSet _boolterm_in_expression2001 = new BitSet(new ulong[]{0x10000000012UL});
		public static readonly BitSet _AND_in_expression2005 = new BitSet(new ulong[]{0x4000E512100000UL});
		public static readonly BitSet _OR_in_expression2010 = new BitSet(new ulong[]{0x4000E512100000UL});
		public static readonly BitSet _boolterm_in_expression2014 = new BitSet(new ulong[]{0x10000000012UL});
		public static readonly BitSet _simple_in_boolterm2031 = new BitSet(new ulong[]{0xA81880002UL});
		public static readonly BitSet _EQ_in_boolterm2035 = new BitSet(new ulong[]{0x4000E512100000UL});
		public static readonly BitSet _LT_in_boolterm2040 = new BitSet(new ulong[]{0x4000E512100000UL});
		public static readonly BitSet _GT_in_boolterm2045 = new BitSet(new ulong[]{0x4000E512100000UL});
		public static readonly BitSet _NE_in_boolterm2050 = new BitSet(new ulong[]{0x4000E512100000UL});
		public static readonly BitSet _LE_in_boolterm2055 = new BitSet(new ulong[]{0x4000E512100000UL});
		public static readonly BitSet _GE_in_boolterm2060 = new BitSet(new ulong[]{0x4000E512100000UL});
		public static readonly BitSet _simple_in_boolterm2064 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _term_in_simple2081 = new BitSet(new ulong[]{0x40400000002UL});
		public static readonly BitSet _PLUS_in_simple2085 = new BitSet(new ulong[]{0x4000E512100000UL});
		public static readonly BitSet _MINUS_in_simple2090 = new BitSet(new ulong[]{0x4000E512100000UL});
		public static readonly BitSet _term_in_simple2094 = new BitSet(new ulong[]{0x40400000002UL});
		public static readonly BitSet _unary_in_term2111 = new BitSet(new ulong[]{0x20000000008002UL});
		public static readonly BitSet _TIMES_in_term2115 = new BitSet(new ulong[]{0x4000E512100000UL});
		public static readonly BitSet _DIVIDE_in_term2120 = new BitSet(new ulong[]{0x4000E512100000UL});
		public static readonly BitSet _unary_in_term2124 = new BitSet(new ulong[]{0x20000000008002UL});
		public static readonly BitSet _NOT_in_unary2141 = new BitSet(new ulong[]{0x4000E112100000UL});
		public static readonly BitSet _odd_not_in_unary2144 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MINUS_in_unary2152 = new BitSet(new ulong[]{0x4000A512100000UL});
		public static readonly BitSet _odd_neg_in_unary2155 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _selector_in_unary2163 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_odd_not2178 = new BitSet(new ulong[]{0x4000E112100000UL});
		public static readonly BitSet _even_not_in_odd_not2181 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _selector_in_odd_not2191 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_even_not2221 = new BitSet(new ulong[]{0x4000E112100000UL});
		public static readonly BitSet _odd_not_in_even_not2224 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _selector_in_even_not2232 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MINUS_in_odd_neg2247 = new BitSet(new ulong[]{0x4000A512100000UL});
		public static readonly BitSet _even_neg_in_odd_neg2250 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _selector_in_odd_neg2260 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MINUS_in_even_neg2290 = new BitSet(new ulong[]{0x4000A512100000UL});
		public static readonly BitSet _odd_neg_in_even_neg2293 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _selector_in_even_neg2301 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _factor_in_selector2316 = new BitSet(new ulong[]{0x10002UL});
		public static readonly BitSet _DOT_in_selector2319 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _ID_in_selector2322 = new BitSet(new ulong[]{0x10002UL});
		public static readonly BitSet _LPAREN_in_factor2339 = new BitSet(new ulong[]{0x4000E512100000UL});
		public static readonly BitSet _expression_in_factor2342 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _RPAREN_in_factor2344 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_factor2355 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _arguments_in_factor2359 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_factor2385 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INTEGER_in_factor2393 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TRUE_in_factor2401 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FALSE_in_factor2409 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEW_in_factor2417 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _ID_in_factor2420 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NULL_in_factor2428 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_arguments2443 = new BitSet(new ulong[]{0x4200E512100000UL});
		public static readonly BitSet _arg_list_in_arguments2446 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _RPAREN_in_arguments2448 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_arg_list2464 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _COMMA_in_arg_list2467 = new BitSet(new ulong[]{0x4000E512100000UL});
		public static readonly BitSet _expression_in_arg_list2469 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _STRUCT_in_synpred1_Mini1104 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _ID_in_synpred1_Mini1106 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _LBRACE_in_synpred1_Mini1108 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRUCT_in_synpred2_Mini1147 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _ID_in_synpred2_Mini1149 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _LBRACE_in_synpred2_Mini1151 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _lvalue_in_synpred3_Mini1571 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _ASSIGN_in_synpred3_Mini1573 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred4_Mini1635 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _LPAREN_in_synpred4_Mini1637 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
